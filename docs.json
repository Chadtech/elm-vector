[{"name":"Vector1","comment":" A vector of length 1\n\n# Vector1\n\n@docs Vector1\n\n# Creation\n\n@docs fromList, repeat, from1, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector1 a`. There are exactly 1 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]]]}],"aliases":[{"name":"Vector1","comment":" A vector that contains exactly 1 elements ","args":["a"],"type":"Vector1.Internal.Vector1 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector1.Vector1 a -> Vector2.Internal.Vector2 a"},{"name":"foldl","comment":" Reduce a `Vector1 a` from the left. ","type":"(a -> b -> b) -> b -> Vector1.Vector1 a -> b"},{"name":"foldr","comment":" Reduce a `Vector1 a` from the right. ","type":"(a -> b -> b) -> b -> Vector1.Vector1 a -> b"},{"name":"from1","comment":" Make a `Vector1 a` from 1 elements ","type":"a -> Vector1.Vector1 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector1 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector1.Vector1 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector1 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector1.Vector1 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector1 a` ","type":"Vector1.Index -> Vector1.Vector1 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector1 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector1.Vector1 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector1.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector1.Index -> a -> b) -> Vector1.Vector1 a -> Vector1.Vector1 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 0 ","type":"Vector1.Vector1 Vector1.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector1 a` using a function that takes an `Index` ","type":"(Vector1.Index -> a) -> Vector1.Vector1 a"},{"name":"initializeFromInt","comment":" Make a `Vector1 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector1.Vector1 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector1 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector1.Index"},{"name":"length","comment":" The length of this vector type, which is 1 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector1 a`. ","type":"(a -> b) -> Vector1.Vector1 a -> Vector1.Vector1 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector1.Vector1 a -> Vector1.Vector1 b -> Vector1.Vector1 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector1.Vector1 a -> Vector1.Vector1 b -> Vector1.Vector1 c -> Vector1.Vector1 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector1.Vector1 a -> Vector1.Vector1 b -> Vector1.Vector1 c -> Vector1.Vector1 d -> Vector1.Vector1 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector1.Vector1 a -> Vector1.Vector1 b -> Vector1.Vector1 c -> Vector1.Vector1 d -> Vector1.Vector1 e -> Vector1.Vector1 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector1.Index -> (a -> a) -> Vector1.Vector1 a -> Vector1.Vector1 a"},{"name":"member","comment":" See if a Vector1 a contains a value ","type":"a -> Vector1.Vector1 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector1.Index -> Maybe.Maybe Vector1.Index"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector1.Index -> Maybe.Maybe Vector1.Index"},{"name":"push","comment":" Add an element to the end of a `Vector1 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector1.Vector1 a -> Vector2.Internal.Vector2 a"},{"name":"repeat","comment":" Make a `Vector1 a` filled with just one item repeated over and over again. ","type":"a -> Vector1.Vector1 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector1 a` ","type":"Vector1.Vector1 a -> Vector1.Vector1 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector1 a` ","type":"Vector1.Index -> a -> Vector1.Vector1 a -> Vector1.Vector1 a"},{"name":"toIndexedList","comment":" Turn a `Vector1 a` elm into a list, where each element is paired with its `Index` ","type":"Vector1.Vector1 a -> List.List ( Vector1.Index, a )"},{"name":"toList","comment":" Convert a `Vector1 a` into a `List a` of length 1 ","type":"Vector1.Vector1 a -> List.List a"}],"binops":[]},{"name":"Vector10","comment":" A vector of length 10\n\n# Vector10\n\n@docs Vector10\n\n# Creation\n\n@docs fromList, repeat, from10, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector10 a`. There are exactly 10 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]]]}],"aliases":[{"name":"Vector10","comment":" A vector that contains exactly 10 elements ","args":["a"],"type":"Vector10.Internal.Vector10 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector10.Vector10 a -> Vector11.Internal.Vector11 a"},{"name":"foldl","comment":" Reduce a `Vector10 a` from the left. ","type":"(a -> b -> b) -> b -> Vector10.Vector10 a -> b"},{"name":"foldr","comment":" Reduce a `Vector10 a` from the right. ","type":"(a -> b -> b) -> b -> Vector10.Vector10 a -> b"},{"name":"from10","comment":" Make a `Vector10 a` from 10 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector10.Vector10 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector10 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector10.Vector10 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector10 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector10.Vector10 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector10 a` ","type":"Vector10.Index -> Vector10.Vector10 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector10 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector10.Vector10 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector10.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector10.Index -> a -> b) -> Vector10.Vector10 a -> Vector10.Vector10 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 9 ","type":"Vector10.Vector10 Vector10.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector10 a` using a function that takes an `Index` ","type":"(Vector10.Index -> a) -> Vector10.Vector10 a"},{"name":"initializeFromInt","comment":" Make a `Vector10 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector10.Vector10 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector10 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector10.Index"},{"name":"length","comment":" The length of this vector type, which is 10 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector10 a`. ","type":"(a -> b) -> Vector10.Vector10 a -> Vector10.Vector10 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector10.Vector10 a -> Vector10.Vector10 b -> Vector10.Vector10 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector10.Vector10 a -> Vector10.Vector10 b -> Vector10.Vector10 c -> Vector10.Vector10 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector10.Vector10 a -> Vector10.Vector10 b -> Vector10.Vector10 c -> Vector10.Vector10 d -> Vector10.Vector10 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector10.Vector10 a -> Vector10.Vector10 b -> Vector10.Vector10 c -> Vector10.Vector10 d -> Vector10.Vector10 e -> Vector10.Vector10 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector10.Index -> (a -> a) -> Vector10.Vector10 a -> Vector10.Vector10 a"},{"name":"member","comment":" See if a Vector10 a contains a value ","type":"a -> Vector10.Vector10 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector10.Index -> Maybe.Maybe Vector10.Index"},{"name":"pop","comment":" Separate a `Vector10 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector10.Vector10 a -> ( Vector9.Internal.Vector9 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector10.Index -> Maybe.Maybe Vector10.Index"},{"name":"push","comment":" Add an element to the end of a `Vector10 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector10.Vector10 a -> Vector11.Internal.Vector11 a"},{"name":"repeat","comment":" Make a `Vector10 a` filled with just one item repeated over and over again. ","type":"a -> Vector10.Vector10 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector10 a` ","type":"Vector10.Vector10 a -> Vector10.Vector10 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector10 a` ","type":"Vector10.Index -> a -> Vector10.Vector10 a -> Vector10.Vector10 a"},{"name":"toIndexedList","comment":" Turn a `Vector10 a` elm into a list, where each element is paired with its `Index` ","type":"Vector10.Vector10 a -> List.List ( Vector10.Index, a )"},{"name":"toList","comment":" Convert a `Vector10 a` into a `List a` of length 10 ","type":"Vector10.Vector10 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector10 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector10.Vector10 a -> ( a, Vector9.Internal.Vector9 a )"}],"binops":[]},{"name":"Vector11","comment":" A vector of length 11\n\n# Vector11\n\n@docs Vector11\n\n# Creation\n\n@docs fromList, repeat, from11, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector11 a`. There are exactly 11 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]]]}],"aliases":[{"name":"Vector11","comment":" A vector that contains exactly 11 elements ","args":["a"],"type":"Vector11.Internal.Vector11 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector11.Vector11 a -> Vector12.Internal.Vector12 a"},{"name":"foldl","comment":" Reduce a `Vector11 a` from the left. ","type":"(a -> b -> b) -> b -> Vector11.Vector11 a -> b"},{"name":"foldr","comment":" Reduce a `Vector11 a` from the right. ","type":"(a -> b -> b) -> b -> Vector11.Vector11 a -> b"},{"name":"from11","comment":" Make a `Vector11 a` from 11 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector11.Vector11 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector11 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector11.Vector11 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector11 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector11.Vector11 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector11 a` ","type":"Vector11.Index -> Vector11.Vector11 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector11 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector11.Vector11 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector11.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector11.Index -> a -> b) -> Vector11.Vector11 a -> Vector11.Vector11 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 10 ","type":"Vector11.Vector11 Vector11.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector11 a` using a function that takes an `Index` ","type":"(Vector11.Index -> a) -> Vector11.Vector11 a"},{"name":"initializeFromInt","comment":" Make a `Vector11 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector11.Vector11 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector11 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector11.Index"},{"name":"length","comment":" The length of this vector type, which is 11 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector11 a`. ","type":"(a -> b) -> Vector11.Vector11 a -> Vector11.Vector11 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector11.Vector11 a -> Vector11.Vector11 b -> Vector11.Vector11 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector11.Vector11 a -> Vector11.Vector11 b -> Vector11.Vector11 c -> Vector11.Vector11 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector11.Vector11 a -> Vector11.Vector11 b -> Vector11.Vector11 c -> Vector11.Vector11 d -> Vector11.Vector11 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector11.Vector11 a -> Vector11.Vector11 b -> Vector11.Vector11 c -> Vector11.Vector11 d -> Vector11.Vector11 e -> Vector11.Vector11 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector11.Index -> (a -> a) -> Vector11.Vector11 a -> Vector11.Vector11 a"},{"name":"member","comment":" See if a Vector11 a contains a value ","type":"a -> Vector11.Vector11 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector11.Index -> Maybe.Maybe Vector11.Index"},{"name":"pop","comment":" Separate a `Vector11 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector11.Vector11 a -> ( Vector10.Internal.Vector10 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector11.Index -> Maybe.Maybe Vector11.Index"},{"name":"push","comment":" Add an element to the end of a `Vector11 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector11.Vector11 a -> Vector12.Internal.Vector12 a"},{"name":"repeat","comment":" Make a `Vector11 a` filled with just one item repeated over and over again. ","type":"a -> Vector11.Vector11 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector11 a` ","type":"Vector11.Vector11 a -> Vector11.Vector11 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector11 a` ","type":"Vector11.Index -> a -> Vector11.Vector11 a -> Vector11.Vector11 a"},{"name":"toIndexedList","comment":" Turn a `Vector11 a` elm into a list, where each element is paired with its `Index` ","type":"Vector11.Vector11 a -> List.List ( Vector11.Index, a )"},{"name":"toList","comment":" Convert a `Vector11 a` into a `List a` of length 11 ","type":"Vector11.Vector11 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector11 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector11.Vector11 a -> ( a, Vector10.Internal.Vector10 a )"}],"binops":[]},{"name":"Vector12","comment":" A vector of length 12\n\n# Vector12\n\n@docs Vector12\n\n# Creation\n\n@docs fromList, repeat, from12, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector12 a`. There are exactly 12 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]]]}],"aliases":[{"name":"Vector12","comment":" A vector that contains exactly 12 elements ","args":["a"],"type":"Vector12.Internal.Vector12 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector12.Vector12 a -> Vector13.Internal.Vector13 a"},{"name":"foldl","comment":" Reduce a `Vector12 a` from the left. ","type":"(a -> b -> b) -> b -> Vector12.Vector12 a -> b"},{"name":"foldr","comment":" Reduce a `Vector12 a` from the right. ","type":"(a -> b -> b) -> b -> Vector12.Vector12 a -> b"},{"name":"from12","comment":" Make a `Vector12 a` from 12 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector12.Vector12 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector12 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector12.Vector12 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector12 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector12.Vector12 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector12 a` ","type":"Vector12.Index -> Vector12.Vector12 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector12 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector12.Vector12 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector12.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector12.Index -> a -> b) -> Vector12.Vector12 a -> Vector12.Vector12 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 11 ","type":"Vector12.Vector12 Vector12.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector12 a` using a function that takes an `Index` ","type":"(Vector12.Index -> a) -> Vector12.Vector12 a"},{"name":"initializeFromInt","comment":" Make a `Vector12 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector12.Vector12 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector12 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector12.Index"},{"name":"length","comment":" The length of this vector type, which is 12 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector12 a`. ","type":"(a -> b) -> Vector12.Vector12 a -> Vector12.Vector12 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector12.Vector12 a -> Vector12.Vector12 b -> Vector12.Vector12 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector12.Vector12 a -> Vector12.Vector12 b -> Vector12.Vector12 c -> Vector12.Vector12 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector12.Vector12 a -> Vector12.Vector12 b -> Vector12.Vector12 c -> Vector12.Vector12 d -> Vector12.Vector12 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector12.Vector12 a -> Vector12.Vector12 b -> Vector12.Vector12 c -> Vector12.Vector12 d -> Vector12.Vector12 e -> Vector12.Vector12 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector12.Index -> (a -> a) -> Vector12.Vector12 a -> Vector12.Vector12 a"},{"name":"member","comment":" See if a Vector12 a contains a value ","type":"a -> Vector12.Vector12 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector12.Index -> Maybe.Maybe Vector12.Index"},{"name":"pop","comment":" Separate a `Vector12 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector12.Vector12 a -> ( Vector11.Internal.Vector11 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector12.Index -> Maybe.Maybe Vector12.Index"},{"name":"push","comment":" Add an element to the end of a `Vector12 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector12.Vector12 a -> Vector13.Internal.Vector13 a"},{"name":"repeat","comment":" Make a `Vector12 a` filled with just one item repeated over and over again. ","type":"a -> Vector12.Vector12 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector12 a` ","type":"Vector12.Vector12 a -> Vector12.Vector12 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector12 a` ","type":"Vector12.Index -> a -> Vector12.Vector12 a -> Vector12.Vector12 a"},{"name":"toIndexedList","comment":" Turn a `Vector12 a` elm into a list, where each element is paired with its `Index` ","type":"Vector12.Vector12 a -> List.List ( Vector12.Index, a )"},{"name":"toList","comment":" Convert a `Vector12 a` into a `List a` of length 12 ","type":"Vector12.Vector12 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector12 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector12.Vector12 a -> ( a, Vector11.Internal.Vector11 a )"}],"binops":[]},{"name":"Vector13","comment":" A vector of length 13\n\n# Vector13\n\n@docs Vector13\n\n# Creation\n\n@docs fromList, repeat, from13, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector13 a`. There are exactly 13 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]]]}],"aliases":[{"name":"Vector13","comment":" A vector that contains exactly 13 elements ","args":["a"],"type":"Vector13.Internal.Vector13 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector13.Vector13 a -> Vector14.Internal.Vector14 a"},{"name":"foldl","comment":" Reduce a `Vector13 a` from the left. ","type":"(a -> b -> b) -> b -> Vector13.Vector13 a -> b"},{"name":"foldr","comment":" Reduce a `Vector13 a` from the right. ","type":"(a -> b -> b) -> b -> Vector13.Vector13 a -> b"},{"name":"from13","comment":" Make a `Vector13 a` from 13 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector13.Vector13 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector13 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector13.Vector13 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector13 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector13.Vector13 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector13 a` ","type":"Vector13.Index -> Vector13.Vector13 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector13 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector13.Vector13 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector13.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector13.Index -> a -> b) -> Vector13.Vector13 a -> Vector13.Vector13 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 12 ","type":"Vector13.Vector13 Vector13.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector13 a` using a function that takes an `Index` ","type":"(Vector13.Index -> a) -> Vector13.Vector13 a"},{"name":"initializeFromInt","comment":" Make a `Vector13 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector13.Vector13 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector13 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector13.Index"},{"name":"length","comment":" The length of this vector type, which is 13 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector13 a`. ","type":"(a -> b) -> Vector13.Vector13 a -> Vector13.Vector13 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector13.Vector13 a -> Vector13.Vector13 b -> Vector13.Vector13 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector13.Vector13 a -> Vector13.Vector13 b -> Vector13.Vector13 c -> Vector13.Vector13 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector13.Vector13 a -> Vector13.Vector13 b -> Vector13.Vector13 c -> Vector13.Vector13 d -> Vector13.Vector13 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector13.Vector13 a -> Vector13.Vector13 b -> Vector13.Vector13 c -> Vector13.Vector13 d -> Vector13.Vector13 e -> Vector13.Vector13 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector13.Index -> (a -> a) -> Vector13.Vector13 a -> Vector13.Vector13 a"},{"name":"member","comment":" See if a Vector13 a contains a value ","type":"a -> Vector13.Vector13 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector13.Index -> Maybe.Maybe Vector13.Index"},{"name":"pop","comment":" Separate a `Vector13 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector13.Vector13 a -> ( Vector12.Internal.Vector12 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector13.Index -> Maybe.Maybe Vector13.Index"},{"name":"push","comment":" Add an element to the end of a `Vector13 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector13.Vector13 a -> Vector14.Internal.Vector14 a"},{"name":"repeat","comment":" Make a `Vector13 a` filled with just one item repeated over and over again. ","type":"a -> Vector13.Vector13 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector13 a` ","type":"Vector13.Vector13 a -> Vector13.Vector13 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector13 a` ","type":"Vector13.Index -> a -> Vector13.Vector13 a -> Vector13.Vector13 a"},{"name":"toIndexedList","comment":" Turn a `Vector13 a` elm into a list, where each element is paired with its `Index` ","type":"Vector13.Vector13 a -> List.List ( Vector13.Index, a )"},{"name":"toList","comment":" Convert a `Vector13 a` into a `List a` of length 13 ","type":"Vector13.Vector13 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector13 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector13.Vector13 a -> ( a, Vector12.Internal.Vector12 a )"}],"binops":[]},{"name":"Vector14","comment":" A vector of length 14\n\n# Vector14\n\n@docs Vector14\n\n# Creation\n\n@docs fromList, repeat, from14, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector14 a`. There are exactly 14 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]]]}],"aliases":[{"name":"Vector14","comment":" A vector that contains exactly 14 elements ","args":["a"],"type":"Vector14.Internal.Vector14 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector14.Vector14 a -> Vector15.Internal.Vector15 a"},{"name":"foldl","comment":" Reduce a `Vector14 a` from the left. ","type":"(a -> b -> b) -> b -> Vector14.Vector14 a -> b"},{"name":"foldr","comment":" Reduce a `Vector14 a` from the right. ","type":"(a -> b -> b) -> b -> Vector14.Vector14 a -> b"},{"name":"from14","comment":" Make a `Vector14 a` from 14 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector14.Vector14 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector14 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector14.Vector14 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector14 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector14.Vector14 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector14 a` ","type":"Vector14.Index -> Vector14.Vector14 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector14 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector14.Vector14 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector14.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector14.Index -> a -> b) -> Vector14.Vector14 a -> Vector14.Vector14 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 13 ","type":"Vector14.Vector14 Vector14.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector14 a` using a function that takes an `Index` ","type":"(Vector14.Index -> a) -> Vector14.Vector14 a"},{"name":"initializeFromInt","comment":" Make a `Vector14 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector14.Vector14 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector14 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector14.Index"},{"name":"length","comment":" The length of this vector type, which is 14 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector14 a`. ","type":"(a -> b) -> Vector14.Vector14 a -> Vector14.Vector14 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector14.Vector14 a -> Vector14.Vector14 b -> Vector14.Vector14 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector14.Vector14 a -> Vector14.Vector14 b -> Vector14.Vector14 c -> Vector14.Vector14 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector14.Vector14 a -> Vector14.Vector14 b -> Vector14.Vector14 c -> Vector14.Vector14 d -> Vector14.Vector14 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector14.Vector14 a -> Vector14.Vector14 b -> Vector14.Vector14 c -> Vector14.Vector14 d -> Vector14.Vector14 e -> Vector14.Vector14 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector14.Index -> (a -> a) -> Vector14.Vector14 a -> Vector14.Vector14 a"},{"name":"member","comment":" See if a Vector14 a contains a value ","type":"a -> Vector14.Vector14 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector14.Index -> Maybe.Maybe Vector14.Index"},{"name":"pop","comment":" Separate a `Vector14 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector14.Vector14 a -> ( Vector13.Internal.Vector13 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector14.Index -> Maybe.Maybe Vector14.Index"},{"name":"push","comment":" Add an element to the end of a `Vector14 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector14.Vector14 a -> Vector15.Internal.Vector15 a"},{"name":"repeat","comment":" Make a `Vector14 a` filled with just one item repeated over and over again. ","type":"a -> Vector14.Vector14 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector14 a` ","type":"Vector14.Vector14 a -> Vector14.Vector14 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector14 a` ","type":"Vector14.Index -> a -> Vector14.Vector14 a -> Vector14.Vector14 a"},{"name":"toIndexedList","comment":" Turn a `Vector14 a` elm into a list, where each element is paired with its `Index` ","type":"Vector14.Vector14 a -> List.List ( Vector14.Index, a )"},{"name":"toList","comment":" Convert a `Vector14 a` into a `List a` of length 14 ","type":"Vector14.Vector14 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector14 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector14.Vector14 a -> ( a, Vector13.Internal.Vector13 a )"}],"binops":[]},{"name":"Vector15","comment":" A vector of length 15\n\n# Vector15\n\n@docs Vector15\n\n# Creation\n\n@docs fromList, repeat, from15, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector15 a`. There are exactly 15 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]]]}],"aliases":[{"name":"Vector15","comment":" A vector that contains exactly 15 elements ","args":["a"],"type":"Vector15.Internal.Vector15 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector15.Vector15 a -> Vector16.Internal.Vector16 a"},{"name":"foldl","comment":" Reduce a `Vector15 a` from the left. ","type":"(a -> b -> b) -> b -> Vector15.Vector15 a -> b"},{"name":"foldr","comment":" Reduce a `Vector15 a` from the right. ","type":"(a -> b -> b) -> b -> Vector15.Vector15 a -> b"},{"name":"from15","comment":" Make a `Vector15 a` from 15 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector15.Vector15 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector15 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector15.Vector15 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector15 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector15.Vector15 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector15 a` ","type":"Vector15.Index -> Vector15.Vector15 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector15 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector15.Vector15 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector15.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector15.Index -> a -> b) -> Vector15.Vector15 a -> Vector15.Vector15 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 14 ","type":"Vector15.Vector15 Vector15.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector15 a` using a function that takes an `Index` ","type":"(Vector15.Index -> a) -> Vector15.Vector15 a"},{"name":"initializeFromInt","comment":" Make a `Vector15 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector15.Vector15 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector15 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector15.Index"},{"name":"length","comment":" The length of this vector type, which is 15 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector15 a`. ","type":"(a -> b) -> Vector15.Vector15 a -> Vector15.Vector15 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector15.Vector15 a -> Vector15.Vector15 b -> Vector15.Vector15 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector15.Vector15 a -> Vector15.Vector15 b -> Vector15.Vector15 c -> Vector15.Vector15 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector15.Vector15 a -> Vector15.Vector15 b -> Vector15.Vector15 c -> Vector15.Vector15 d -> Vector15.Vector15 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector15.Vector15 a -> Vector15.Vector15 b -> Vector15.Vector15 c -> Vector15.Vector15 d -> Vector15.Vector15 e -> Vector15.Vector15 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector15.Index -> (a -> a) -> Vector15.Vector15 a -> Vector15.Vector15 a"},{"name":"member","comment":" See if a Vector15 a contains a value ","type":"a -> Vector15.Vector15 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector15.Index -> Maybe.Maybe Vector15.Index"},{"name":"pop","comment":" Separate a `Vector15 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector15.Vector15 a -> ( Vector14.Internal.Vector14 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector15.Index -> Maybe.Maybe Vector15.Index"},{"name":"push","comment":" Add an element to the end of a `Vector15 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector15.Vector15 a -> Vector16.Internal.Vector16 a"},{"name":"repeat","comment":" Make a `Vector15 a` filled with just one item repeated over and over again. ","type":"a -> Vector15.Vector15 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector15 a` ","type":"Vector15.Vector15 a -> Vector15.Vector15 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector15 a` ","type":"Vector15.Index -> a -> Vector15.Vector15 a -> Vector15.Vector15 a"},{"name":"toIndexedList","comment":" Turn a `Vector15 a` elm into a list, where each element is paired with its `Index` ","type":"Vector15.Vector15 a -> List.List ( Vector15.Index, a )"},{"name":"toList","comment":" Convert a `Vector15 a` into a `List a` of length 15 ","type":"Vector15.Vector15 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector15 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector15.Vector15 a -> ( a, Vector14.Internal.Vector14 a )"}],"binops":[]},{"name":"Vector16","comment":" A vector of length 16\n\n# Vector16\n\n@docs Vector16\n\n# Creation\n\n@docs fromList, repeat, from16, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector16 a`. There are exactly 16 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]]]}],"aliases":[{"name":"Vector16","comment":" A vector that contains exactly 16 elements ","args":["a"],"type":"Vector16.Internal.Vector16 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector16.Vector16 a -> Vector17.Internal.Vector17 a"},{"name":"foldl","comment":" Reduce a `Vector16 a` from the left. ","type":"(a -> b -> b) -> b -> Vector16.Vector16 a -> b"},{"name":"foldr","comment":" Reduce a `Vector16 a` from the right. ","type":"(a -> b -> b) -> b -> Vector16.Vector16 a -> b"},{"name":"from16","comment":" Make a `Vector16 a` from 16 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector16.Vector16 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector16 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector16.Vector16 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector16 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector16.Vector16 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector16 a` ","type":"Vector16.Index -> Vector16.Vector16 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector16 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector16.Vector16 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector16.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector16.Index -> a -> b) -> Vector16.Vector16 a -> Vector16.Vector16 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 15 ","type":"Vector16.Vector16 Vector16.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector16 a` using a function that takes an `Index` ","type":"(Vector16.Index -> a) -> Vector16.Vector16 a"},{"name":"initializeFromInt","comment":" Make a `Vector16 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector16.Vector16 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector16 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector16.Index"},{"name":"length","comment":" The length of this vector type, which is 16 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector16 a`. ","type":"(a -> b) -> Vector16.Vector16 a -> Vector16.Vector16 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector16.Vector16 a -> Vector16.Vector16 b -> Vector16.Vector16 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector16.Vector16 a -> Vector16.Vector16 b -> Vector16.Vector16 c -> Vector16.Vector16 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector16.Vector16 a -> Vector16.Vector16 b -> Vector16.Vector16 c -> Vector16.Vector16 d -> Vector16.Vector16 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector16.Vector16 a -> Vector16.Vector16 b -> Vector16.Vector16 c -> Vector16.Vector16 d -> Vector16.Vector16 e -> Vector16.Vector16 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector16.Index -> (a -> a) -> Vector16.Vector16 a -> Vector16.Vector16 a"},{"name":"member","comment":" See if a Vector16 a contains a value ","type":"a -> Vector16.Vector16 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector16.Index -> Maybe.Maybe Vector16.Index"},{"name":"pop","comment":" Separate a `Vector16 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector16.Vector16 a -> ( Vector15.Internal.Vector15 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector16.Index -> Maybe.Maybe Vector16.Index"},{"name":"push","comment":" Add an element to the end of a `Vector16 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector16.Vector16 a -> Vector17.Internal.Vector17 a"},{"name":"repeat","comment":" Make a `Vector16 a` filled with just one item repeated over and over again. ","type":"a -> Vector16.Vector16 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector16 a` ","type":"Vector16.Vector16 a -> Vector16.Vector16 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector16 a` ","type":"Vector16.Index -> a -> Vector16.Vector16 a -> Vector16.Vector16 a"},{"name":"toIndexedList","comment":" Turn a `Vector16 a` elm into a list, where each element is paired with its `Index` ","type":"Vector16.Vector16 a -> List.List ( Vector16.Index, a )"},{"name":"toList","comment":" Convert a `Vector16 a` into a `List a` of length 16 ","type":"Vector16.Vector16 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector16 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector16.Vector16 a -> ( a, Vector15.Internal.Vector15 a )"}],"binops":[]},{"name":"Vector17","comment":" A vector of length 17\n\n# Vector17\n\n@docs Vector17\n\n# Creation\n\n@docs fromList, repeat, from17, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector17 a`. There are exactly 17 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]]]}],"aliases":[{"name":"Vector17","comment":" A vector that contains exactly 17 elements ","args":["a"],"type":"Vector17.Internal.Vector17 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector17.Vector17 a -> Vector18.Internal.Vector18 a"},{"name":"foldl","comment":" Reduce a `Vector17 a` from the left. ","type":"(a -> b -> b) -> b -> Vector17.Vector17 a -> b"},{"name":"foldr","comment":" Reduce a `Vector17 a` from the right. ","type":"(a -> b -> b) -> b -> Vector17.Vector17 a -> b"},{"name":"from17","comment":" Make a `Vector17 a` from 17 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector17.Vector17 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector17 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector17.Vector17 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector17 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector17.Vector17 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector17 a` ","type":"Vector17.Index -> Vector17.Vector17 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector17 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector17.Vector17 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector17.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector17.Index -> a -> b) -> Vector17.Vector17 a -> Vector17.Vector17 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 16 ","type":"Vector17.Vector17 Vector17.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector17 a` using a function that takes an `Index` ","type":"(Vector17.Index -> a) -> Vector17.Vector17 a"},{"name":"initializeFromInt","comment":" Make a `Vector17 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector17.Vector17 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector17 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector17.Index"},{"name":"length","comment":" The length of this vector type, which is 17 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector17 a`. ","type":"(a -> b) -> Vector17.Vector17 a -> Vector17.Vector17 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector17.Vector17 a -> Vector17.Vector17 b -> Vector17.Vector17 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector17.Vector17 a -> Vector17.Vector17 b -> Vector17.Vector17 c -> Vector17.Vector17 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector17.Vector17 a -> Vector17.Vector17 b -> Vector17.Vector17 c -> Vector17.Vector17 d -> Vector17.Vector17 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector17.Vector17 a -> Vector17.Vector17 b -> Vector17.Vector17 c -> Vector17.Vector17 d -> Vector17.Vector17 e -> Vector17.Vector17 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector17.Index -> (a -> a) -> Vector17.Vector17 a -> Vector17.Vector17 a"},{"name":"member","comment":" See if a Vector17 a contains a value ","type":"a -> Vector17.Vector17 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector17.Index -> Maybe.Maybe Vector17.Index"},{"name":"pop","comment":" Separate a `Vector17 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector17.Vector17 a -> ( Vector16.Internal.Vector16 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector17.Index -> Maybe.Maybe Vector17.Index"},{"name":"push","comment":" Add an element to the end of a `Vector17 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector17.Vector17 a -> Vector18.Internal.Vector18 a"},{"name":"repeat","comment":" Make a `Vector17 a` filled with just one item repeated over and over again. ","type":"a -> Vector17.Vector17 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector17 a` ","type":"Vector17.Vector17 a -> Vector17.Vector17 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector17 a` ","type":"Vector17.Index -> a -> Vector17.Vector17 a -> Vector17.Vector17 a"},{"name":"toIndexedList","comment":" Turn a `Vector17 a` elm into a list, where each element is paired with its `Index` ","type":"Vector17.Vector17 a -> List.List ( Vector17.Index, a )"},{"name":"toList","comment":" Convert a `Vector17 a` into a `List a` of length 17 ","type":"Vector17.Vector17 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector17 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector17.Vector17 a -> ( a, Vector16.Internal.Vector16 a )"}],"binops":[]},{"name":"Vector18","comment":" A vector of length 18\n\n# Vector18\n\n@docs Vector18\n\n# Creation\n\n@docs fromList, repeat, from18, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector18 a`. There are exactly 18 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]]]}],"aliases":[{"name":"Vector18","comment":" A vector that contains exactly 18 elements ","args":["a"],"type":"Vector18.Internal.Vector18 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector18.Vector18 a -> Vector19.Internal.Vector19 a"},{"name":"foldl","comment":" Reduce a `Vector18 a` from the left. ","type":"(a -> b -> b) -> b -> Vector18.Vector18 a -> b"},{"name":"foldr","comment":" Reduce a `Vector18 a` from the right. ","type":"(a -> b -> b) -> b -> Vector18.Vector18 a -> b"},{"name":"from18","comment":" Make a `Vector18 a` from 18 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector18.Vector18 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector18 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector18.Vector18 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector18 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector18.Vector18 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector18 a` ","type":"Vector18.Index -> Vector18.Vector18 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector18 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector18.Vector18 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector18.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector18.Index -> a -> b) -> Vector18.Vector18 a -> Vector18.Vector18 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 17 ","type":"Vector18.Vector18 Vector18.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector18 a` using a function that takes an `Index` ","type":"(Vector18.Index -> a) -> Vector18.Vector18 a"},{"name":"initializeFromInt","comment":" Make a `Vector18 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector18.Vector18 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector18 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector18.Index"},{"name":"length","comment":" The length of this vector type, which is 18 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector18 a`. ","type":"(a -> b) -> Vector18.Vector18 a -> Vector18.Vector18 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector18.Vector18 a -> Vector18.Vector18 b -> Vector18.Vector18 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector18.Vector18 a -> Vector18.Vector18 b -> Vector18.Vector18 c -> Vector18.Vector18 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector18.Vector18 a -> Vector18.Vector18 b -> Vector18.Vector18 c -> Vector18.Vector18 d -> Vector18.Vector18 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector18.Vector18 a -> Vector18.Vector18 b -> Vector18.Vector18 c -> Vector18.Vector18 d -> Vector18.Vector18 e -> Vector18.Vector18 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector18.Index -> (a -> a) -> Vector18.Vector18 a -> Vector18.Vector18 a"},{"name":"member","comment":" See if a Vector18 a contains a value ","type":"a -> Vector18.Vector18 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector18.Index -> Maybe.Maybe Vector18.Index"},{"name":"pop","comment":" Separate a `Vector18 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector18.Vector18 a -> ( Vector17.Internal.Vector17 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector18.Index -> Maybe.Maybe Vector18.Index"},{"name":"push","comment":" Add an element to the end of a `Vector18 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector18.Vector18 a -> Vector19.Internal.Vector19 a"},{"name":"repeat","comment":" Make a `Vector18 a` filled with just one item repeated over and over again. ","type":"a -> Vector18.Vector18 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector18 a` ","type":"Vector18.Vector18 a -> Vector18.Vector18 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector18 a` ","type":"Vector18.Index -> a -> Vector18.Vector18 a -> Vector18.Vector18 a"},{"name":"toIndexedList","comment":" Turn a `Vector18 a` elm into a list, where each element is paired with its `Index` ","type":"Vector18.Vector18 a -> List.List ( Vector18.Index, a )"},{"name":"toList","comment":" Convert a `Vector18 a` into a `List a` of length 18 ","type":"Vector18.Vector18 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector18 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector18.Vector18 a -> ( a, Vector17.Internal.Vector17 a )"}],"binops":[]},{"name":"Vector19","comment":" A vector of length 19\n\n# Vector19\n\n@docs Vector19\n\n# Creation\n\n@docs fromList, repeat, from19, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector19 a`. There are exactly 19 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]]]}],"aliases":[{"name":"Vector19","comment":" A vector that contains exactly 19 elements ","args":["a"],"type":"Vector19.Internal.Vector19 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector19.Vector19 a -> Vector20.Internal.Vector20 a"},{"name":"foldl","comment":" Reduce a `Vector19 a` from the left. ","type":"(a -> b -> b) -> b -> Vector19.Vector19 a -> b"},{"name":"foldr","comment":" Reduce a `Vector19 a` from the right. ","type":"(a -> b -> b) -> b -> Vector19.Vector19 a -> b"},{"name":"from19","comment":" Make a `Vector19 a` from 19 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector19.Vector19 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector19 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector19.Vector19 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector19 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector19.Vector19 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector19 a` ","type":"Vector19.Index -> Vector19.Vector19 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector19 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector19.Vector19 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector19.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector19.Index -> a -> b) -> Vector19.Vector19 a -> Vector19.Vector19 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 18 ","type":"Vector19.Vector19 Vector19.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector19 a` using a function that takes an `Index` ","type":"(Vector19.Index -> a) -> Vector19.Vector19 a"},{"name":"initializeFromInt","comment":" Make a `Vector19 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector19.Vector19 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector19 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector19.Index"},{"name":"length","comment":" The length of this vector type, which is 19 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector19 a`. ","type":"(a -> b) -> Vector19.Vector19 a -> Vector19.Vector19 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector19.Vector19 a -> Vector19.Vector19 b -> Vector19.Vector19 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector19.Vector19 a -> Vector19.Vector19 b -> Vector19.Vector19 c -> Vector19.Vector19 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector19.Vector19 a -> Vector19.Vector19 b -> Vector19.Vector19 c -> Vector19.Vector19 d -> Vector19.Vector19 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector19.Vector19 a -> Vector19.Vector19 b -> Vector19.Vector19 c -> Vector19.Vector19 d -> Vector19.Vector19 e -> Vector19.Vector19 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector19.Index -> (a -> a) -> Vector19.Vector19 a -> Vector19.Vector19 a"},{"name":"member","comment":" See if a Vector19 a contains a value ","type":"a -> Vector19.Vector19 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector19.Index -> Maybe.Maybe Vector19.Index"},{"name":"pop","comment":" Separate a `Vector19 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector19.Vector19 a -> ( Vector18.Internal.Vector18 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector19.Index -> Maybe.Maybe Vector19.Index"},{"name":"push","comment":" Add an element to the end of a `Vector19 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector19.Vector19 a -> Vector20.Internal.Vector20 a"},{"name":"repeat","comment":" Make a `Vector19 a` filled with just one item repeated over and over again. ","type":"a -> Vector19.Vector19 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector19 a` ","type":"Vector19.Vector19 a -> Vector19.Vector19 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector19 a` ","type":"Vector19.Index -> a -> Vector19.Vector19 a -> Vector19.Vector19 a"},{"name":"toIndexedList","comment":" Turn a `Vector19 a` elm into a list, where each element is paired with its `Index` ","type":"Vector19.Vector19 a -> List.List ( Vector19.Index, a )"},{"name":"toList","comment":" Convert a `Vector19 a` into a `List a` of length 19 ","type":"Vector19.Vector19 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector19 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector19.Vector19 a -> ( a, Vector18.Internal.Vector18 a )"}],"binops":[]},{"name":"Vector2","comment":" A vector of length 2\n\n# Vector2\n\n@docs Vector2\n\n# Creation\n\n@docs fromList, repeat, from2, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector2 a`. There are exactly 2 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]]]}],"aliases":[{"name":"Vector2","comment":" A vector that contains exactly 2 elements ","args":["a"],"type":"Vector2.Internal.Vector2 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector2.Vector2 a -> Vector3.Internal.Vector3 a"},{"name":"foldl","comment":" Reduce a `Vector2 a` from the left. ","type":"(a -> b -> b) -> b -> Vector2.Vector2 a -> b"},{"name":"foldr","comment":" Reduce a `Vector2 a` from the right. ","type":"(a -> b -> b) -> b -> Vector2.Vector2 a -> b"},{"name":"from2","comment":" Make a `Vector2 a` from 2 elements ","type":"a -> a -> Vector2.Vector2 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector2 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector2.Vector2 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector2 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector2.Vector2 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector2 a` ","type":"Vector2.Index -> Vector2.Vector2 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector2 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector2.Vector2 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector2.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector2.Index -> a -> b) -> Vector2.Vector2 a -> Vector2.Vector2 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 1 ","type":"Vector2.Vector2 Vector2.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector2 a` using a function that takes an `Index` ","type":"(Vector2.Index -> a) -> Vector2.Vector2 a"},{"name":"initializeFromInt","comment":" Make a `Vector2 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector2.Vector2 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector2 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector2.Index"},{"name":"length","comment":" The length of this vector type, which is 2 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector2 a`. ","type":"(a -> b) -> Vector2.Vector2 a -> Vector2.Vector2 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector2.Vector2 a -> Vector2.Vector2 b -> Vector2.Vector2 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector2.Vector2 a -> Vector2.Vector2 b -> Vector2.Vector2 c -> Vector2.Vector2 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector2.Vector2 a -> Vector2.Vector2 b -> Vector2.Vector2 c -> Vector2.Vector2 d -> Vector2.Vector2 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector2.Vector2 a -> Vector2.Vector2 b -> Vector2.Vector2 c -> Vector2.Vector2 d -> Vector2.Vector2 e -> Vector2.Vector2 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector2.Index -> (a -> a) -> Vector2.Vector2 a -> Vector2.Vector2 a"},{"name":"member","comment":" See if a Vector2 a contains a value ","type":"a -> Vector2.Vector2 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector2.Index -> Maybe.Maybe Vector2.Index"},{"name":"pop","comment":" Separate a `Vector2 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector2.Vector2 a -> ( Vector1.Internal.Vector1 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector2.Index -> Maybe.Maybe Vector2.Index"},{"name":"push","comment":" Add an element to the end of a `Vector2 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector2.Vector2 a -> Vector3.Internal.Vector3 a"},{"name":"repeat","comment":" Make a `Vector2 a` filled with just one item repeated over and over again. ","type":"a -> Vector2.Vector2 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector2 a` ","type":"Vector2.Vector2 a -> Vector2.Vector2 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector2 a` ","type":"Vector2.Index -> a -> Vector2.Vector2 a -> Vector2.Vector2 a"},{"name":"toIndexedList","comment":" Turn a `Vector2 a` elm into a list, where each element is paired with its `Index` ","type":"Vector2.Vector2 a -> List.List ( Vector2.Index, a )"},{"name":"toList","comment":" Convert a `Vector2 a` into a `List a` of length 2 ","type":"Vector2.Vector2 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector2 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector2.Vector2 a -> ( a, Vector1.Internal.Vector1 a )"}],"binops":[]},{"name":"Vector20","comment":" A vector of length 20\n\n# Vector20\n\n@docs Vector20\n\n# Creation\n\n@docs fromList, repeat, from20, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector20 a`. There are exactly 20 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]]]}],"aliases":[{"name":"Vector20","comment":" A vector that contains exactly 20 elements ","args":["a"],"type":"Vector20.Internal.Vector20 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector20.Vector20 a -> Vector21.Internal.Vector21 a"},{"name":"foldl","comment":" Reduce a `Vector20 a` from the left. ","type":"(a -> b -> b) -> b -> Vector20.Vector20 a -> b"},{"name":"foldr","comment":" Reduce a `Vector20 a` from the right. ","type":"(a -> b -> b) -> b -> Vector20.Vector20 a -> b"},{"name":"from20","comment":" Make a `Vector20 a` from 20 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector20.Vector20 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector20 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector20.Vector20 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector20 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector20.Vector20 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector20 a` ","type":"Vector20.Index -> Vector20.Vector20 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector20 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector20.Vector20 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector20.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector20.Index -> a -> b) -> Vector20.Vector20 a -> Vector20.Vector20 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 19 ","type":"Vector20.Vector20 Vector20.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector20 a` using a function that takes an `Index` ","type":"(Vector20.Index -> a) -> Vector20.Vector20 a"},{"name":"initializeFromInt","comment":" Make a `Vector20 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector20.Vector20 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector20 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector20.Index"},{"name":"length","comment":" The length of this vector type, which is 20 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector20 a`. ","type":"(a -> b) -> Vector20.Vector20 a -> Vector20.Vector20 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector20.Vector20 a -> Vector20.Vector20 b -> Vector20.Vector20 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector20.Vector20 a -> Vector20.Vector20 b -> Vector20.Vector20 c -> Vector20.Vector20 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector20.Vector20 a -> Vector20.Vector20 b -> Vector20.Vector20 c -> Vector20.Vector20 d -> Vector20.Vector20 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector20.Vector20 a -> Vector20.Vector20 b -> Vector20.Vector20 c -> Vector20.Vector20 d -> Vector20.Vector20 e -> Vector20.Vector20 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector20.Index -> (a -> a) -> Vector20.Vector20 a -> Vector20.Vector20 a"},{"name":"member","comment":" See if a Vector20 a contains a value ","type":"a -> Vector20.Vector20 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector20.Index -> Maybe.Maybe Vector20.Index"},{"name":"pop","comment":" Separate a `Vector20 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector20.Vector20 a -> ( Vector19.Internal.Vector19 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector20.Index -> Maybe.Maybe Vector20.Index"},{"name":"push","comment":" Add an element to the end of a `Vector20 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector20.Vector20 a -> Vector21.Internal.Vector21 a"},{"name":"repeat","comment":" Make a `Vector20 a` filled with just one item repeated over and over again. ","type":"a -> Vector20.Vector20 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector20 a` ","type":"Vector20.Vector20 a -> Vector20.Vector20 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector20 a` ","type":"Vector20.Index -> a -> Vector20.Vector20 a -> Vector20.Vector20 a"},{"name":"toIndexedList","comment":" Turn a `Vector20 a` elm into a list, where each element is paired with its `Index` ","type":"Vector20.Vector20 a -> List.List ( Vector20.Index, a )"},{"name":"toList","comment":" Convert a `Vector20 a` into a `List a` of length 20 ","type":"Vector20.Vector20 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector20 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector20.Vector20 a -> ( a, Vector19.Internal.Vector19 a )"}],"binops":[]},{"name":"Vector21","comment":" A vector of length 21\n\n# Vector21\n\n@docs Vector21\n\n# Creation\n\n@docs fromList, repeat, from21, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector21 a`. There are exactly 21 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]]]}],"aliases":[{"name":"Vector21","comment":" A vector that contains exactly 21 elements ","args":["a"],"type":"Vector21.Internal.Vector21 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector21.Vector21 a -> Vector22.Internal.Vector22 a"},{"name":"foldl","comment":" Reduce a `Vector21 a` from the left. ","type":"(a -> b -> b) -> b -> Vector21.Vector21 a -> b"},{"name":"foldr","comment":" Reduce a `Vector21 a` from the right. ","type":"(a -> b -> b) -> b -> Vector21.Vector21 a -> b"},{"name":"from21","comment":" Make a `Vector21 a` from 21 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector21.Vector21 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector21 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector21.Vector21 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector21 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector21.Vector21 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector21 a` ","type":"Vector21.Index -> Vector21.Vector21 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector21 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector21.Vector21 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector21.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector21.Index -> a -> b) -> Vector21.Vector21 a -> Vector21.Vector21 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 20 ","type":"Vector21.Vector21 Vector21.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector21 a` using a function that takes an `Index` ","type":"(Vector21.Index -> a) -> Vector21.Vector21 a"},{"name":"initializeFromInt","comment":" Make a `Vector21 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector21.Vector21 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector21 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector21.Index"},{"name":"length","comment":" The length of this vector type, which is 21 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector21 a`. ","type":"(a -> b) -> Vector21.Vector21 a -> Vector21.Vector21 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector21.Vector21 a -> Vector21.Vector21 b -> Vector21.Vector21 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector21.Vector21 a -> Vector21.Vector21 b -> Vector21.Vector21 c -> Vector21.Vector21 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector21.Vector21 a -> Vector21.Vector21 b -> Vector21.Vector21 c -> Vector21.Vector21 d -> Vector21.Vector21 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector21.Vector21 a -> Vector21.Vector21 b -> Vector21.Vector21 c -> Vector21.Vector21 d -> Vector21.Vector21 e -> Vector21.Vector21 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector21.Index -> (a -> a) -> Vector21.Vector21 a -> Vector21.Vector21 a"},{"name":"member","comment":" See if a Vector21 a contains a value ","type":"a -> Vector21.Vector21 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector21.Index -> Maybe.Maybe Vector21.Index"},{"name":"pop","comment":" Separate a `Vector21 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector21.Vector21 a -> ( Vector20.Internal.Vector20 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector21.Index -> Maybe.Maybe Vector21.Index"},{"name":"push","comment":" Add an element to the end of a `Vector21 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector21.Vector21 a -> Vector22.Internal.Vector22 a"},{"name":"repeat","comment":" Make a `Vector21 a` filled with just one item repeated over and over again. ","type":"a -> Vector21.Vector21 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector21 a` ","type":"Vector21.Vector21 a -> Vector21.Vector21 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector21 a` ","type":"Vector21.Index -> a -> Vector21.Vector21 a -> Vector21.Vector21 a"},{"name":"toIndexedList","comment":" Turn a `Vector21 a` elm into a list, where each element is paired with its `Index` ","type":"Vector21.Vector21 a -> List.List ( Vector21.Index, a )"},{"name":"toList","comment":" Convert a `Vector21 a` into a `List a` of length 21 ","type":"Vector21.Vector21 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector21 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector21.Vector21 a -> ( a, Vector20.Internal.Vector20 a )"}],"binops":[]},{"name":"Vector22","comment":" A vector of length 22\n\n# Vector22\n\n@docs Vector22\n\n# Creation\n\n@docs fromList, repeat, from22, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector22 a`. There are exactly 22 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]]]}],"aliases":[{"name":"Vector22","comment":" A vector that contains exactly 22 elements ","args":["a"],"type":"Vector22.Internal.Vector22 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector22.Vector22 a -> Vector23.Internal.Vector23 a"},{"name":"foldl","comment":" Reduce a `Vector22 a` from the left. ","type":"(a -> b -> b) -> b -> Vector22.Vector22 a -> b"},{"name":"foldr","comment":" Reduce a `Vector22 a` from the right. ","type":"(a -> b -> b) -> b -> Vector22.Vector22 a -> b"},{"name":"from22","comment":" Make a `Vector22 a` from 22 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector22.Vector22 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector22 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector22.Vector22 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector22 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector22.Vector22 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector22 a` ","type":"Vector22.Index -> Vector22.Vector22 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector22 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector22.Vector22 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector22.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector22.Index -> a -> b) -> Vector22.Vector22 a -> Vector22.Vector22 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 21 ","type":"Vector22.Vector22 Vector22.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector22 a` using a function that takes an `Index` ","type":"(Vector22.Index -> a) -> Vector22.Vector22 a"},{"name":"initializeFromInt","comment":" Make a `Vector22 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector22.Vector22 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector22 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector22.Index"},{"name":"length","comment":" The length of this vector type, which is 22 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector22 a`. ","type":"(a -> b) -> Vector22.Vector22 a -> Vector22.Vector22 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector22.Vector22 a -> Vector22.Vector22 b -> Vector22.Vector22 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector22.Vector22 a -> Vector22.Vector22 b -> Vector22.Vector22 c -> Vector22.Vector22 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector22.Vector22 a -> Vector22.Vector22 b -> Vector22.Vector22 c -> Vector22.Vector22 d -> Vector22.Vector22 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector22.Vector22 a -> Vector22.Vector22 b -> Vector22.Vector22 c -> Vector22.Vector22 d -> Vector22.Vector22 e -> Vector22.Vector22 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector22.Index -> (a -> a) -> Vector22.Vector22 a -> Vector22.Vector22 a"},{"name":"member","comment":" See if a Vector22 a contains a value ","type":"a -> Vector22.Vector22 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector22.Index -> Maybe.Maybe Vector22.Index"},{"name":"pop","comment":" Separate a `Vector22 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector22.Vector22 a -> ( Vector21.Internal.Vector21 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector22.Index -> Maybe.Maybe Vector22.Index"},{"name":"push","comment":" Add an element to the end of a `Vector22 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector22.Vector22 a -> Vector23.Internal.Vector23 a"},{"name":"repeat","comment":" Make a `Vector22 a` filled with just one item repeated over and over again. ","type":"a -> Vector22.Vector22 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector22 a` ","type":"Vector22.Vector22 a -> Vector22.Vector22 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector22 a` ","type":"Vector22.Index -> a -> Vector22.Vector22 a -> Vector22.Vector22 a"},{"name":"toIndexedList","comment":" Turn a `Vector22 a` elm into a list, where each element is paired with its `Index` ","type":"Vector22.Vector22 a -> List.List ( Vector22.Index, a )"},{"name":"toList","comment":" Convert a `Vector22 a` into a `List a` of length 22 ","type":"Vector22.Vector22 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector22 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector22.Vector22 a -> ( a, Vector21.Internal.Vector21 a )"}],"binops":[]},{"name":"Vector23","comment":" A vector of length 23\n\n# Vector23\n\n@docs Vector23\n\n# Creation\n\n@docs fromList, repeat, from23, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector23 a`. There are exactly 23 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]]]}],"aliases":[{"name":"Vector23","comment":" A vector that contains exactly 23 elements ","args":["a"],"type":"Vector23.Internal.Vector23 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector23.Vector23 a -> Vector24.Internal.Vector24 a"},{"name":"foldl","comment":" Reduce a `Vector23 a` from the left. ","type":"(a -> b -> b) -> b -> Vector23.Vector23 a -> b"},{"name":"foldr","comment":" Reduce a `Vector23 a` from the right. ","type":"(a -> b -> b) -> b -> Vector23.Vector23 a -> b"},{"name":"from23","comment":" Make a `Vector23 a` from 23 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector23.Vector23 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector23 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector23.Vector23 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector23 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector23.Vector23 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector23 a` ","type":"Vector23.Index -> Vector23.Vector23 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector23 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector23.Vector23 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector23.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector23.Index -> a -> b) -> Vector23.Vector23 a -> Vector23.Vector23 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 22 ","type":"Vector23.Vector23 Vector23.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector23 a` using a function that takes an `Index` ","type":"(Vector23.Index -> a) -> Vector23.Vector23 a"},{"name":"initializeFromInt","comment":" Make a `Vector23 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector23.Vector23 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector23 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector23.Index"},{"name":"length","comment":" The length of this vector type, which is 23 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector23 a`. ","type":"(a -> b) -> Vector23.Vector23 a -> Vector23.Vector23 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector23.Vector23 a -> Vector23.Vector23 b -> Vector23.Vector23 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector23.Vector23 a -> Vector23.Vector23 b -> Vector23.Vector23 c -> Vector23.Vector23 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector23.Vector23 a -> Vector23.Vector23 b -> Vector23.Vector23 c -> Vector23.Vector23 d -> Vector23.Vector23 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector23.Vector23 a -> Vector23.Vector23 b -> Vector23.Vector23 c -> Vector23.Vector23 d -> Vector23.Vector23 e -> Vector23.Vector23 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector23.Index -> (a -> a) -> Vector23.Vector23 a -> Vector23.Vector23 a"},{"name":"member","comment":" See if a Vector23 a contains a value ","type":"a -> Vector23.Vector23 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector23.Index -> Maybe.Maybe Vector23.Index"},{"name":"pop","comment":" Separate a `Vector23 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector23.Vector23 a -> ( Vector22.Internal.Vector22 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector23.Index -> Maybe.Maybe Vector23.Index"},{"name":"push","comment":" Add an element to the end of a `Vector23 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector23.Vector23 a -> Vector24.Internal.Vector24 a"},{"name":"repeat","comment":" Make a `Vector23 a` filled with just one item repeated over and over again. ","type":"a -> Vector23.Vector23 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector23 a` ","type":"Vector23.Vector23 a -> Vector23.Vector23 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector23 a` ","type":"Vector23.Index -> a -> Vector23.Vector23 a -> Vector23.Vector23 a"},{"name":"toIndexedList","comment":" Turn a `Vector23 a` elm into a list, where each element is paired with its `Index` ","type":"Vector23.Vector23 a -> List.List ( Vector23.Index, a )"},{"name":"toList","comment":" Convert a `Vector23 a` into a `List a` of length 23 ","type":"Vector23.Vector23 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector23 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector23.Vector23 a -> ( a, Vector22.Internal.Vector22 a )"}],"binops":[]},{"name":"Vector24","comment":" A vector of length 24\n\n# Vector24\n\n@docs Vector24\n\n# Creation\n\n@docs fromList, repeat, from24, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector24 a`. There are exactly 24 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]]]}],"aliases":[{"name":"Vector24","comment":" A vector that contains exactly 24 elements ","args":["a"],"type":"Vector24.Internal.Vector24 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector24.Vector24 a -> Vector25.Internal.Vector25 a"},{"name":"foldl","comment":" Reduce a `Vector24 a` from the left. ","type":"(a -> b -> b) -> b -> Vector24.Vector24 a -> b"},{"name":"foldr","comment":" Reduce a `Vector24 a` from the right. ","type":"(a -> b -> b) -> b -> Vector24.Vector24 a -> b"},{"name":"from24","comment":" Make a `Vector24 a` from 24 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector24.Vector24 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector24 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector24.Vector24 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector24 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector24.Vector24 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector24 a` ","type":"Vector24.Index -> Vector24.Vector24 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector24 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector24.Vector24 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector24.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector24.Index -> a -> b) -> Vector24.Vector24 a -> Vector24.Vector24 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 23 ","type":"Vector24.Vector24 Vector24.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector24 a` using a function that takes an `Index` ","type":"(Vector24.Index -> a) -> Vector24.Vector24 a"},{"name":"initializeFromInt","comment":" Make a `Vector24 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector24.Vector24 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector24 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector24.Index"},{"name":"length","comment":" The length of this vector type, which is 24 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector24 a`. ","type":"(a -> b) -> Vector24.Vector24 a -> Vector24.Vector24 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector24.Vector24 a -> Vector24.Vector24 b -> Vector24.Vector24 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector24.Vector24 a -> Vector24.Vector24 b -> Vector24.Vector24 c -> Vector24.Vector24 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector24.Vector24 a -> Vector24.Vector24 b -> Vector24.Vector24 c -> Vector24.Vector24 d -> Vector24.Vector24 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector24.Vector24 a -> Vector24.Vector24 b -> Vector24.Vector24 c -> Vector24.Vector24 d -> Vector24.Vector24 e -> Vector24.Vector24 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector24.Index -> (a -> a) -> Vector24.Vector24 a -> Vector24.Vector24 a"},{"name":"member","comment":" See if a Vector24 a contains a value ","type":"a -> Vector24.Vector24 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector24.Index -> Maybe.Maybe Vector24.Index"},{"name":"pop","comment":" Separate a `Vector24 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector24.Vector24 a -> ( Vector23.Internal.Vector23 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector24.Index -> Maybe.Maybe Vector24.Index"},{"name":"push","comment":" Add an element to the end of a `Vector24 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector24.Vector24 a -> Vector25.Internal.Vector25 a"},{"name":"repeat","comment":" Make a `Vector24 a` filled with just one item repeated over and over again. ","type":"a -> Vector24.Vector24 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector24 a` ","type":"Vector24.Vector24 a -> Vector24.Vector24 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector24 a` ","type":"Vector24.Index -> a -> Vector24.Vector24 a -> Vector24.Vector24 a"},{"name":"toIndexedList","comment":" Turn a `Vector24 a` elm into a list, where each element is paired with its `Index` ","type":"Vector24.Vector24 a -> List.List ( Vector24.Index, a )"},{"name":"toList","comment":" Convert a `Vector24 a` into a `List a` of length 24 ","type":"Vector24.Vector24 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector24 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector24.Vector24 a -> ( a, Vector23.Internal.Vector23 a )"}],"binops":[]},{"name":"Vector25","comment":" A vector of length 25\n\n# Vector25\n\n@docs Vector25\n\n# Creation\n\n@docs fromList, repeat, from25, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector25 a`. There are exactly 25 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]]]}],"aliases":[{"name":"Vector25","comment":" A vector that contains exactly 25 elements ","args":["a"],"type":"Vector25.Internal.Vector25 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector25.Vector25 a -> Vector26.Internal.Vector26 a"},{"name":"foldl","comment":" Reduce a `Vector25 a` from the left. ","type":"(a -> b -> b) -> b -> Vector25.Vector25 a -> b"},{"name":"foldr","comment":" Reduce a `Vector25 a` from the right. ","type":"(a -> b -> b) -> b -> Vector25.Vector25 a -> b"},{"name":"from25","comment":" Make a `Vector25 a` from 25 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector25.Vector25 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector25 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector25.Vector25 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector25 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector25.Vector25 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector25 a` ","type":"Vector25.Index -> Vector25.Vector25 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector25 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector25.Vector25 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector25.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector25.Index -> a -> b) -> Vector25.Vector25 a -> Vector25.Vector25 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 24 ","type":"Vector25.Vector25 Vector25.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector25 a` using a function that takes an `Index` ","type":"(Vector25.Index -> a) -> Vector25.Vector25 a"},{"name":"initializeFromInt","comment":" Make a `Vector25 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector25.Vector25 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector25 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector25.Index"},{"name":"length","comment":" The length of this vector type, which is 25 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector25 a`. ","type":"(a -> b) -> Vector25.Vector25 a -> Vector25.Vector25 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector25.Vector25 a -> Vector25.Vector25 b -> Vector25.Vector25 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector25.Vector25 a -> Vector25.Vector25 b -> Vector25.Vector25 c -> Vector25.Vector25 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector25.Vector25 a -> Vector25.Vector25 b -> Vector25.Vector25 c -> Vector25.Vector25 d -> Vector25.Vector25 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector25.Vector25 a -> Vector25.Vector25 b -> Vector25.Vector25 c -> Vector25.Vector25 d -> Vector25.Vector25 e -> Vector25.Vector25 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector25.Index -> (a -> a) -> Vector25.Vector25 a -> Vector25.Vector25 a"},{"name":"member","comment":" See if a Vector25 a contains a value ","type":"a -> Vector25.Vector25 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector25.Index -> Maybe.Maybe Vector25.Index"},{"name":"pop","comment":" Separate a `Vector25 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector25.Vector25 a -> ( Vector24.Internal.Vector24 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector25.Index -> Maybe.Maybe Vector25.Index"},{"name":"push","comment":" Add an element to the end of a `Vector25 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector25.Vector25 a -> Vector26.Internal.Vector26 a"},{"name":"repeat","comment":" Make a `Vector25 a` filled with just one item repeated over and over again. ","type":"a -> Vector25.Vector25 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector25 a` ","type":"Vector25.Vector25 a -> Vector25.Vector25 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector25 a` ","type":"Vector25.Index -> a -> Vector25.Vector25 a -> Vector25.Vector25 a"},{"name":"toIndexedList","comment":" Turn a `Vector25 a` elm into a list, where each element is paired with its `Index` ","type":"Vector25.Vector25 a -> List.List ( Vector25.Index, a )"},{"name":"toList","comment":" Convert a `Vector25 a` into a `List a` of length 25 ","type":"Vector25.Vector25 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector25 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector25.Vector25 a -> ( a, Vector24.Internal.Vector24 a )"}],"binops":[]},{"name":"Vector26","comment":" A vector of length 26\n\n# Vector26\n\n@docs Vector26\n\n# Creation\n\n@docs fromList, repeat, from26, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector26 a`. There are exactly 26 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]]]}],"aliases":[{"name":"Vector26","comment":" A vector that contains exactly 26 elements ","args":["a"],"type":"Vector26.Internal.Vector26 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector26.Vector26 a -> Vector27.Internal.Vector27 a"},{"name":"foldl","comment":" Reduce a `Vector26 a` from the left. ","type":"(a -> b -> b) -> b -> Vector26.Vector26 a -> b"},{"name":"foldr","comment":" Reduce a `Vector26 a` from the right. ","type":"(a -> b -> b) -> b -> Vector26.Vector26 a -> b"},{"name":"from26","comment":" Make a `Vector26 a` from 26 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector26.Vector26 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector26 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector26.Vector26 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector26 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector26.Vector26 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector26 a` ","type":"Vector26.Index -> Vector26.Vector26 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector26 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector26.Vector26 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector26.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector26.Index -> a -> b) -> Vector26.Vector26 a -> Vector26.Vector26 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 25 ","type":"Vector26.Vector26 Vector26.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector26 a` using a function that takes an `Index` ","type":"(Vector26.Index -> a) -> Vector26.Vector26 a"},{"name":"initializeFromInt","comment":" Make a `Vector26 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector26.Vector26 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector26 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector26.Index"},{"name":"length","comment":" The length of this vector type, which is 26 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector26 a`. ","type":"(a -> b) -> Vector26.Vector26 a -> Vector26.Vector26 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector26.Vector26 a -> Vector26.Vector26 b -> Vector26.Vector26 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector26.Vector26 a -> Vector26.Vector26 b -> Vector26.Vector26 c -> Vector26.Vector26 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector26.Vector26 a -> Vector26.Vector26 b -> Vector26.Vector26 c -> Vector26.Vector26 d -> Vector26.Vector26 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector26.Vector26 a -> Vector26.Vector26 b -> Vector26.Vector26 c -> Vector26.Vector26 d -> Vector26.Vector26 e -> Vector26.Vector26 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector26.Index -> (a -> a) -> Vector26.Vector26 a -> Vector26.Vector26 a"},{"name":"member","comment":" See if a Vector26 a contains a value ","type":"a -> Vector26.Vector26 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector26.Index -> Maybe.Maybe Vector26.Index"},{"name":"pop","comment":" Separate a `Vector26 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector26.Vector26 a -> ( Vector25.Internal.Vector25 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector26.Index -> Maybe.Maybe Vector26.Index"},{"name":"push","comment":" Add an element to the end of a `Vector26 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector26.Vector26 a -> Vector27.Internal.Vector27 a"},{"name":"repeat","comment":" Make a `Vector26 a` filled with just one item repeated over and over again. ","type":"a -> Vector26.Vector26 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector26 a` ","type":"Vector26.Vector26 a -> Vector26.Vector26 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector26 a` ","type":"Vector26.Index -> a -> Vector26.Vector26 a -> Vector26.Vector26 a"},{"name":"toIndexedList","comment":" Turn a `Vector26 a` elm into a list, where each element is paired with its `Index` ","type":"Vector26.Vector26 a -> List.List ( Vector26.Index, a )"},{"name":"toList","comment":" Convert a `Vector26 a` into a `List a` of length 26 ","type":"Vector26.Vector26 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector26 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector26.Vector26 a -> ( a, Vector25.Internal.Vector25 a )"}],"binops":[]},{"name":"Vector27","comment":" A vector of length 27\n\n# Vector27\n\n@docs Vector27\n\n# Creation\n\n@docs fromList, repeat, from27, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector27 a`. There are exactly 27 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]]]}],"aliases":[{"name":"Vector27","comment":" A vector that contains exactly 27 elements ","args":["a"],"type":"Vector27.Internal.Vector27 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector27.Vector27 a -> Vector28.Internal.Vector28 a"},{"name":"foldl","comment":" Reduce a `Vector27 a` from the left. ","type":"(a -> b -> b) -> b -> Vector27.Vector27 a -> b"},{"name":"foldr","comment":" Reduce a `Vector27 a` from the right. ","type":"(a -> b -> b) -> b -> Vector27.Vector27 a -> b"},{"name":"from27","comment":" Make a `Vector27 a` from 27 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector27.Vector27 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector27 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector27.Vector27 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector27 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector27.Vector27 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector27 a` ","type":"Vector27.Index -> Vector27.Vector27 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector27 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector27.Vector27 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector27.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector27.Index -> a -> b) -> Vector27.Vector27 a -> Vector27.Vector27 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 26 ","type":"Vector27.Vector27 Vector27.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector27 a` using a function that takes an `Index` ","type":"(Vector27.Index -> a) -> Vector27.Vector27 a"},{"name":"initializeFromInt","comment":" Make a `Vector27 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector27.Vector27 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector27 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector27.Index"},{"name":"length","comment":" The length of this vector type, which is 27 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector27 a`. ","type":"(a -> b) -> Vector27.Vector27 a -> Vector27.Vector27 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector27.Vector27 a -> Vector27.Vector27 b -> Vector27.Vector27 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector27.Vector27 a -> Vector27.Vector27 b -> Vector27.Vector27 c -> Vector27.Vector27 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector27.Vector27 a -> Vector27.Vector27 b -> Vector27.Vector27 c -> Vector27.Vector27 d -> Vector27.Vector27 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector27.Vector27 a -> Vector27.Vector27 b -> Vector27.Vector27 c -> Vector27.Vector27 d -> Vector27.Vector27 e -> Vector27.Vector27 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector27.Index -> (a -> a) -> Vector27.Vector27 a -> Vector27.Vector27 a"},{"name":"member","comment":" See if a Vector27 a contains a value ","type":"a -> Vector27.Vector27 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector27.Index -> Maybe.Maybe Vector27.Index"},{"name":"pop","comment":" Separate a `Vector27 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector27.Vector27 a -> ( Vector26.Internal.Vector26 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector27.Index -> Maybe.Maybe Vector27.Index"},{"name":"push","comment":" Add an element to the end of a `Vector27 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector27.Vector27 a -> Vector28.Internal.Vector28 a"},{"name":"repeat","comment":" Make a `Vector27 a` filled with just one item repeated over and over again. ","type":"a -> Vector27.Vector27 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector27 a` ","type":"Vector27.Vector27 a -> Vector27.Vector27 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector27 a` ","type":"Vector27.Index -> a -> Vector27.Vector27 a -> Vector27.Vector27 a"},{"name":"toIndexedList","comment":" Turn a `Vector27 a` elm into a list, where each element is paired with its `Index` ","type":"Vector27.Vector27 a -> List.List ( Vector27.Index, a )"},{"name":"toList","comment":" Convert a `Vector27 a` into a `List a` of length 27 ","type":"Vector27.Vector27 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector27 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector27.Vector27 a -> ( a, Vector26.Internal.Vector26 a )"}],"binops":[]},{"name":"Vector28","comment":" A vector of length 28\n\n# Vector28\n\n@docs Vector28\n\n# Creation\n\n@docs fromList, repeat, from28, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector28 a`. There are exactly 28 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]]]}],"aliases":[{"name":"Vector28","comment":" A vector that contains exactly 28 elements ","args":["a"],"type":"Vector28.Internal.Vector28 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector28.Vector28 a -> Vector29.Internal.Vector29 a"},{"name":"foldl","comment":" Reduce a `Vector28 a` from the left. ","type":"(a -> b -> b) -> b -> Vector28.Vector28 a -> b"},{"name":"foldr","comment":" Reduce a `Vector28 a` from the right. ","type":"(a -> b -> b) -> b -> Vector28.Vector28 a -> b"},{"name":"from28","comment":" Make a `Vector28 a` from 28 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector28.Vector28 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector28 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector28.Vector28 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector28 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector28.Vector28 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector28 a` ","type":"Vector28.Index -> Vector28.Vector28 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector28 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector28.Vector28 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector28.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector28.Index -> a -> b) -> Vector28.Vector28 a -> Vector28.Vector28 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 27 ","type":"Vector28.Vector28 Vector28.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector28 a` using a function that takes an `Index` ","type":"(Vector28.Index -> a) -> Vector28.Vector28 a"},{"name":"initializeFromInt","comment":" Make a `Vector28 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector28.Vector28 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector28 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector28.Index"},{"name":"length","comment":" The length of this vector type, which is 28 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector28 a`. ","type":"(a -> b) -> Vector28.Vector28 a -> Vector28.Vector28 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector28.Vector28 a -> Vector28.Vector28 b -> Vector28.Vector28 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector28.Vector28 a -> Vector28.Vector28 b -> Vector28.Vector28 c -> Vector28.Vector28 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector28.Vector28 a -> Vector28.Vector28 b -> Vector28.Vector28 c -> Vector28.Vector28 d -> Vector28.Vector28 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector28.Vector28 a -> Vector28.Vector28 b -> Vector28.Vector28 c -> Vector28.Vector28 d -> Vector28.Vector28 e -> Vector28.Vector28 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector28.Index -> (a -> a) -> Vector28.Vector28 a -> Vector28.Vector28 a"},{"name":"member","comment":" See if a Vector28 a contains a value ","type":"a -> Vector28.Vector28 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector28.Index -> Maybe.Maybe Vector28.Index"},{"name":"pop","comment":" Separate a `Vector28 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector28.Vector28 a -> ( Vector27.Internal.Vector27 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector28.Index -> Maybe.Maybe Vector28.Index"},{"name":"push","comment":" Add an element to the end of a `Vector28 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector28.Vector28 a -> Vector29.Internal.Vector29 a"},{"name":"repeat","comment":" Make a `Vector28 a` filled with just one item repeated over and over again. ","type":"a -> Vector28.Vector28 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector28 a` ","type":"Vector28.Vector28 a -> Vector28.Vector28 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector28 a` ","type":"Vector28.Index -> a -> Vector28.Vector28 a -> Vector28.Vector28 a"},{"name":"toIndexedList","comment":" Turn a `Vector28 a` elm into a list, where each element is paired with its `Index` ","type":"Vector28.Vector28 a -> List.List ( Vector28.Index, a )"},{"name":"toList","comment":" Convert a `Vector28 a` into a `List a` of length 28 ","type":"Vector28.Vector28 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector28 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector28.Vector28 a -> ( a, Vector27.Internal.Vector27 a )"}],"binops":[]},{"name":"Vector29","comment":" A vector of length 29\n\n# Vector29\n\n@docs Vector29\n\n# Creation\n\n@docs fromList, repeat, from29, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector29 a`. There are exactly 29 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]]]}],"aliases":[{"name":"Vector29","comment":" A vector that contains exactly 29 elements ","args":["a"],"type":"Vector29.Internal.Vector29 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector29.Vector29 a -> Vector30.Internal.Vector30 a"},{"name":"foldl","comment":" Reduce a `Vector29 a` from the left. ","type":"(a -> b -> b) -> b -> Vector29.Vector29 a -> b"},{"name":"foldr","comment":" Reduce a `Vector29 a` from the right. ","type":"(a -> b -> b) -> b -> Vector29.Vector29 a -> b"},{"name":"from29","comment":" Make a `Vector29 a` from 29 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector29.Vector29 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector29 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector29.Vector29 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector29 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector29.Vector29 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector29 a` ","type":"Vector29.Index -> Vector29.Vector29 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector29 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector29.Vector29 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector29.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector29.Index -> a -> b) -> Vector29.Vector29 a -> Vector29.Vector29 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 28 ","type":"Vector29.Vector29 Vector29.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector29 a` using a function that takes an `Index` ","type":"(Vector29.Index -> a) -> Vector29.Vector29 a"},{"name":"initializeFromInt","comment":" Make a `Vector29 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector29.Vector29 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector29 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector29.Index"},{"name":"length","comment":" The length of this vector type, which is 29 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector29 a`. ","type":"(a -> b) -> Vector29.Vector29 a -> Vector29.Vector29 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector29.Vector29 a -> Vector29.Vector29 b -> Vector29.Vector29 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector29.Vector29 a -> Vector29.Vector29 b -> Vector29.Vector29 c -> Vector29.Vector29 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector29.Vector29 a -> Vector29.Vector29 b -> Vector29.Vector29 c -> Vector29.Vector29 d -> Vector29.Vector29 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector29.Vector29 a -> Vector29.Vector29 b -> Vector29.Vector29 c -> Vector29.Vector29 d -> Vector29.Vector29 e -> Vector29.Vector29 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector29.Index -> (a -> a) -> Vector29.Vector29 a -> Vector29.Vector29 a"},{"name":"member","comment":" See if a Vector29 a contains a value ","type":"a -> Vector29.Vector29 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector29.Index -> Maybe.Maybe Vector29.Index"},{"name":"pop","comment":" Separate a `Vector29 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector29.Vector29 a -> ( Vector28.Internal.Vector28 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector29.Index -> Maybe.Maybe Vector29.Index"},{"name":"push","comment":" Add an element to the end of a `Vector29 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector29.Vector29 a -> Vector30.Internal.Vector30 a"},{"name":"repeat","comment":" Make a `Vector29 a` filled with just one item repeated over and over again. ","type":"a -> Vector29.Vector29 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector29 a` ","type":"Vector29.Vector29 a -> Vector29.Vector29 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector29 a` ","type":"Vector29.Index -> a -> Vector29.Vector29 a -> Vector29.Vector29 a"},{"name":"toIndexedList","comment":" Turn a `Vector29 a` elm into a list, where each element is paired with its `Index` ","type":"Vector29.Vector29 a -> List.List ( Vector29.Index, a )"},{"name":"toList","comment":" Convert a `Vector29 a` into a `List a` of length 29 ","type":"Vector29.Vector29 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector29 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector29.Vector29 a -> ( a, Vector28.Internal.Vector28 a )"}],"binops":[]},{"name":"Vector3","comment":" A vector of length 3\n\n# Vector3\n\n@docs Vector3\n\n# Creation\n\n@docs fromList, repeat, from3, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector3 a`. There are exactly 3 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]]]}],"aliases":[{"name":"Vector3","comment":" A vector that contains exactly 3 elements ","args":["a"],"type":"Vector3.Internal.Vector3 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector3.Vector3 a -> Vector4.Internal.Vector4 a"},{"name":"foldl","comment":" Reduce a `Vector3 a` from the left. ","type":"(a -> b -> b) -> b -> Vector3.Vector3 a -> b"},{"name":"foldr","comment":" Reduce a `Vector3 a` from the right. ","type":"(a -> b -> b) -> b -> Vector3.Vector3 a -> b"},{"name":"from3","comment":" Make a `Vector3 a` from 3 elements ","type":"a -> a -> a -> Vector3.Vector3 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector3 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector3.Vector3 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector3 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector3.Vector3 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector3 a` ","type":"Vector3.Index -> Vector3.Vector3 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector3 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector3.Vector3 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector3.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector3.Index -> a -> b) -> Vector3.Vector3 a -> Vector3.Vector3 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 2 ","type":"Vector3.Vector3 Vector3.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector3 a` using a function that takes an `Index` ","type":"(Vector3.Index -> a) -> Vector3.Vector3 a"},{"name":"initializeFromInt","comment":" Make a `Vector3 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector3.Vector3 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector3 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector3.Index"},{"name":"length","comment":" The length of this vector type, which is 3 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector3 a`. ","type":"(a -> b) -> Vector3.Vector3 a -> Vector3.Vector3 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector3.Vector3 a -> Vector3.Vector3 b -> Vector3.Vector3 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector3.Vector3 a -> Vector3.Vector3 b -> Vector3.Vector3 c -> Vector3.Vector3 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector3.Vector3 a -> Vector3.Vector3 b -> Vector3.Vector3 c -> Vector3.Vector3 d -> Vector3.Vector3 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector3.Vector3 a -> Vector3.Vector3 b -> Vector3.Vector3 c -> Vector3.Vector3 d -> Vector3.Vector3 e -> Vector3.Vector3 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector3.Index -> (a -> a) -> Vector3.Vector3 a -> Vector3.Vector3 a"},{"name":"member","comment":" See if a Vector3 a contains a value ","type":"a -> Vector3.Vector3 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector3.Index -> Maybe.Maybe Vector3.Index"},{"name":"pop","comment":" Separate a `Vector3 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector3.Vector3 a -> ( Vector2.Internal.Vector2 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector3.Index -> Maybe.Maybe Vector3.Index"},{"name":"push","comment":" Add an element to the end of a `Vector3 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector3.Vector3 a -> Vector4.Internal.Vector4 a"},{"name":"repeat","comment":" Make a `Vector3 a` filled with just one item repeated over and over again. ","type":"a -> Vector3.Vector3 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector3 a` ","type":"Vector3.Vector3 a -> Vector3.Vector3 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector3 a` ","type":"Vector3.Index -> a -> Vector3.Vector3 a -> Vector3.Vector3 a"},{"name":"toIndexedList","comment":" Turn a `Vector3 a` elm into a list, where each element is paired with its `Index` ","type":"Vector3.Vector3 a -> List.List ( Vector3.Index, a )"},{"name":"toList","comment":" Convert a `Vector3 a` into a `List a` of length 3 ","type":"Vector3.Vector3 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector3 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector3.Vector3 a -> ( a, Vector2.Internal.Vector2 a )"}],"binops":[]},{"name":"Vector30","comment":" A vector of length 30\n\n# Vector30\n\n@docs Vector30\n\n# Creation\n\n@docs fromList, repeat, from30, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector30 a`. There are exactly 30 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]]]}],"aliases":[{"name":"Vector30","comment":" A vector that contains exactly 30 elements ","args":["a"],"type":"Vector30.Internal.Vector30 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector30.Vector30 a -> Vector31.Internal.Vector31 a"},{"name":"foldl","comment":" Reduce a `Vector30 a` from the left. ","type":"(a -> b -> b) -> b -> Vector30.Vector30 a -> b"},{"name":"foldr","comment":" Reduce a `Vector30 a` from the right. ","type":"(a -> b -> b) -> b -> Vector30.Vector30 a -> b"},{"name":"from30","comment":" Make a `Vector30 a` from 30 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector30.Vector30 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector30 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector30.Vector30 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector30 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector30.Vector30 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector30 a` ","type":"Vector30.Index -> Vector30.Vector30 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector30 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector30.Vector30 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector30.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector30.Index -> a -> b) -> Vector30.Vector30 a -> Vector30.Vector30 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 29 ","type":"Vector30.Vector30 Vector30.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector30 a` using a function that takes an `Index` ","type":"(Vector30.Index -> a) -> Vector30.Vector30 a"},{"name":"initializeFromInt","comment":" Make a `Vector30 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector30.Vector30 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector30 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector30.Index"},{"name":"length","comment":" The length of this vector type, which is 30 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector30 a`. ","type":"(a -> b) -> Vector30.Vector30 a -> Vector30.Vector30 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector30.Vector30 a -> Vector30.Vector30 b -> Vector30.Vector30 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector30.Vector30 a -> Vector30.Vector30 b -> Vector30.Vector30 c -> Vector30.Vector30 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector30.Vector30 a -> Vector30.Vector30 b -> Vector30.Vector30 c -> Vector30.Vector30 d -> Vector30.Vector30 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector30.Vector30 a -> Vector30.Vector30 b -> Vector30.Vector30 c -> Vector30.Vector30 d -> Vector30.Vector30 e -> Vector30.Vector30 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector30.Index -> (a -> a) -> Vector30.Vector30 a -> Vector30.Vector30 a"},{"name":"member","comment":" See if a Vector30 a contains a value ","type":"a -> Vector30.Vector30 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector30.Index -> Maybe.Maybe Vector30.Index"},{"name":"pop","comment":" Separate a `Vector30 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector30.Vector30 a -> ( Vector29.Internal.Vector29 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector30.Index -> Maybe.Maybe Vector30.Index"},{"name":"push","comment":" Add an element to the end of a `Vector30 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector30.Vector30 a -> Vector31.Internal.Vector31 a"},{"name":"repeat","comment":" Make a `Vector30 a` filled with just one item repeated over and over again. ","type":"a -> Vector30.Vector30 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector30 a` ","type":"Vector30.Vector30 a -> Vector30.Vector30 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector30 a` ","type":"Vector30.Index -> a -> Vector30.Vector30 a -> Vector30.Vector30 a"},{"name":"toIndexedList","comment":" Turn a `Vector30 a` elm into a list, where each element is paired with its `Index` ","type":"Vector30.Vector30 a -> List.List ( Vector30.Index, a )"},{"name":"toList","comment":" Convert a `Vector30 a` into a `List a` of length 30 ","type":"Vector30.Vector30 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector30 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector30.Vector30 a -> ( a, Vector29.Internal.Vector29 a )"}],"binops":[]},{"name":"Vector31","comment":" A vector of length 31\n\n# Vector31\n\n@docs Vector31\n\n# Creation\n\n@docs fromList, repeat, from31, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector31 a`. There are exactly 31 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]]]}],"aliases":[{"name":"Vector31","comment":" A vector that contains exactly 31 elements ","args":["a"],"type":"Vector31.Internal.Vector31 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector31.Vector31 a -> Vector32.Internal.Vector32 a"},{"name":"foldl","comment":" Reduce a `Vector31 a` from the left. ","type":"(a -> b -> b) -> b -> Vector31.Vector31 a -> b"},{"name":"foldr","comment":" Reduce a `Vector31 a` from the right. ","type":"(a -> b -> b) -> b -> Vector31.Vector31 a -> b"},{"name":"from31","comment":" Make a `Vector31 a` from 31 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector31.Vector31 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector31 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector31.Vector31 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector31 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector31.Vector31 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector31 a` ","type":"Vector31.Index -> Vector31.Vector31 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector31 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector31.Vector31 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector31.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector31.Index -> a -> b) -> Vector31.Vector31 a -> Vector31.Vector31 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 30 ","type":"Vector31.Vector31 Vector31.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector31 a` using a function that takes an `Index` ","type":"(Vector31.Index -> a) -> Vector31.Vector31 a"},{"name":"initializeFromInt","comment":" Make a `Vector31 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector31.Vector31 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector31 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector31.Index"},{"name":"length","comment":" The length of this vector type, which is 31 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector31 a`. ","type":"(a -> b) -> Vector31.Vector31 a -> Vector31.Vector31 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector31.Vector31 a -> Vector31.Vector31 b -> Vector31.Vector31 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector31.Vector31 a -> Vector31.Vector31 b -> Vector31.Vector31 c -> Vector31.Vector31 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector31.Vector31 a -> Vector31.Vector31 b -> Vector31.Vector31 c -> Vector31.Vector31 d -> Vector31.Vector31 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector31.Vector31 a -> Vector31.Vector31 b -> Vector31.Vector31 c -> Vector31.Vector31 d -> Vector31.Vector31 e -> Vector31.Vector31 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector31.Index -> (a -> a) -> Vector31.Vector31 a -> Vector31.Vector31 a"},{"name":"member","comment":" See if a Vector31 a contains a value ","type":"a -> Vector31.Vector31 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector31.Index -> Maybe.Maybe Vector31.Index"},{"name":"pop","comment":" Separate a `Vector31 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector31.Vector31 a -> ( Vector30.Internal.Vector30 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector31.Index -> Maybe.Maybe Vector31.Index"},{"name":"push","comment":" Add an element to the end of a `Vector31 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector31.Vector31 a -> Vector32.Internal.Vector32 a"},{"name":"repeat","comment":" Make a `Vector31 a` filled with just one item repeated over and over again. ","type":"a -> Vector31.Vector31 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector31 a` ","type":"Vector31.Vector31 a -> Vector31.Vector31 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector31 a` ","type":"Vector31.Index -> a -> Vector31.Vector31 a -> Vector31.Vector31 a"},{"name":"toIndexedList","comment":" Turn a `Vector31 a` elm into a list, where each element is paired with its `Index` ","type":"Vector31.Vector31 a -> List.List ( Vector31.Index, a )"},{"name":"toList","comment":" Convert a `Vector31 a` into a `List a` of length 31 ","type":"Vector31.Vector31 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector31 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector31.Vector31 a -> ( a, Vector30.Internal.Vector30 a )"}],"binops":[]},{"name":"Vector32","comment":" A vector of length 32\n\n# Vector32\n\n@docs Vector32\n\n# Creation\n\n@docs fromList, repeat, from32, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector32 a`. There are exactly 32 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]]]}],"aliases":[{"name":"Vector32","comment":" A vector that contains exactly 32 elements ","args":["a"],"type":"Vector32.Internal.Vector32 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector32.Vector32 a -> Vector33.Internal.Vector33 a"},{"name":"foldl","comment":" Reduce a `Vector32 a` from the left. ","type":"(a -> b -> b) -> b -> Vector32.Vector32 a -> b"},{"name":"foldr","comment":" Reduce a `Vector32 a` from the right. ","type":"(a -> b -> b) -> b -> Vector32.Vector32 a -> b"},{"name":"from32","comment":" Make a `Vector32 a` from 32 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector32.Vector32 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector32 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector32.Vector32 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector32 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector32.Vector32 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector32 a` ","type":"Vector32.Index -> Vector32.Vector32 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector32 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector32.Vector32 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector32.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector32.Index -> a -> b) -> Vector32.Vector32 a -> Vector32.Vector32 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 31 ","type":"Vector32.Vector32 Vector32.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector32 a` using a function that takes an `Index` ","type":"(Vector32.Index -> a) -> Vector32.Vector32 a"},{"name":"initializeFromInt","comment":" Make a `Vector32 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector32.Vector32 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector32 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector32.Index"},{"name":"length","comment":" The length of this vector type, which is 32 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector32 a`. ","type":"(a -> b) -> Vector32.Vector32 a -> Vector32.Vector32 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector32.Vector32 a -> Vector32.Vector32 b -> Vector32.Vector32 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector32.Vector32 a -> Vector32.Vector32 b -> Vector32.Vector32 c -> Vector32.Vector32 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector32.Vector32 a -> Vector32.Vector32 b -> Vector32.Vector32 c -> Vector32.Vector32 d -> Vector32.Vector32 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector32.Vector32 a -> Vector32.Vector32 b -> Vector32.Vector32 c -> Vector32.Vector32 d -> Vector32.Vector32 e -> Vector32.Vector32 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector32.Index -> (a -> a) -> Vector32.Vector32 a -> Vector32.Vector32 a"},{"name":"member","comment":" See if a Vector32 a contains a value ","type":"a -> Vector32.Vector32 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector32.Index -> Maybe.Maybe Vector32.Index"},{"name":"pop","comment":" Separate a `Vector32 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector32.Vector32 a -> ( Vector31.Internal.Vector31 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector32.Index -> Maybe.Maybe Vector32.Index"},{"name":"push","comment":" Add an element to the end of a `Vector32 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector32.Vector32 a -> Vector33.Internal.Vector33 a"},{"name":"repeat","comment":" Make a `Vector32 a` filled with just one item repeated over and over again. ","type":"a -> Vector32.Vector32 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector32 a` ","type":"Vector32.Vector32 a -> Vector32.Vector32 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector32 a` ","type":"Vector32.Index -> a -> Vector32.Vector32 a -> Vector32.Vector32 a"},{"name":"toIndexedList","comment":" Turn a `Vector32 a` elm into a list, where each element is paired with its `Index` ","type":"Vector32.Vector32 a -> List.List ( Vector32.Index, a )"},{"name":"toList","comment":" Convert a `Vector32 a` into a `List a` of length 32 ","type":"Vector32.Vector32 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector32 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector32.Vector32 a -> ( a, Vector31.Internal.Vector31 a )"}],"binops":[]},{"name":"Vector33","comment":" A vector of length 33\n\n# Vector33\n\n@docs Vector33\n\n# Creation\n\n@docs fromList, repeat, from33, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector33 a`. There are exactly 33 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]]]}],"aliases":[{"name":"Vector33","comment":" A vector that contains exactly 33 elements ","args":["a"],"type":"Vector33.Internal.Vector33 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector33.Vector33 a -> Vector34.Internal.Vector34 a"},{"name":"foldl","comment":" Reduce a `Vector33 a` from the left. ","type":"(a -> b -> b) -> b -> Vector33.Vector33 a -> b"},{"name":"foldr","comment":" Reduce a `Vector33 a` from the right. ","type":"(a -> b -> b) -> b -> Vector33.Vector33 a -> b"},{"name":"from33","comment":" Make a `Vector33 a` from 33 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector33.Vector33 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector33 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector33.Vector33 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector33 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector33.Vector33 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector33 a` ","type":"Vector33.Index -> Vector33.Vector33 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector33 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector33.Vector33 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector33.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector33.Index -> a -> b) -> Vector33.Vector33 a -> Vector33.Vector33 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 32 ","type":"Vector33.Vector33 Vector33.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector33 a` using a function that takes an `Index` ","type":"(Vector33.Index -> a) -> Vector33.Vector33 a"},{"name":"initializeFromInt","comment":" Make a `Vector33 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector33.Vector33 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector33 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector33.Index"},{"name":"length","comment":" The length of this vector type, which is 33 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector33 a`. ","type":"(a -> b) -> Vector33.Vector33 a -> Vector33.Vector33 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector33.Vector33 a -> Vector33.Vector33 b -> Vector33.Vector33 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector33.Vector33 a -> Vector33.Vector33 b -> Vector33.Vector33 c -> Vector33.Vector33 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector33.Vector33 a -> Vector33.Vector33 b -> Vector33.Vector33 c -> Vector33.Vector33 d -> Vector33.Vector33 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector33.Vector33 a -> Vector33.Vector33 b -> Vector33.Vector33 c -> Vector33.Vector33 d -> Vector33.Vector33 e -> Vector33.Vector33 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector33.Index -> (a -> a) -> Vector33.Vector33 a -> Vector33.Vector33 a"},{"name":"member","comment":" See if a Vector33 a contains a value ","type":"a -> Vector33.Vector33 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector33.Index -> Maybe.Maybe Vector33.Index"},{"name":"pop","comment":" Separate a `Vector33 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector33.Vector33 a -> ( Vector32.Internal.Vector32 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector33.Index -> Maybe.Maybe Vector33.Index"},{"name":"push","comment":" Add an element to the end of a `Vector33 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector33.Vector33 a -> Vector34.Internal.Vector34 a"},{"name":"repeat","comment":" Make a `Vector33 a` filled with just one item repeated over and over again. ","type":"a -> Vector33.Vector33 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector33 a` ","type":"Vector33.Vector33 a -> Vector33.Vector33 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector33 a` ","type":"Vector33.Index -> a -> Vector33.Vector33 a -> Vector33.Vector33 a"},{"name":"toIndexedList","comment":" Turn a `Vector33 a` elm into a list, where each element is paired with its `Index` ","type":"Vector33.Vector33 a -> List.List ( Vector33.Index, a )"},{"name":"toList","comment":" Convert a `Vector33 a` into a `List a` of length 33 ","type":"Vector33.Vector33 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector33 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector33.Vector33 a -> ( a, Vector32.Internal.Vector32 a )"}],"binops":[]},{"name":"Vector34","comment":" A vector of length 34\n\n# Vector34\n\n@docs Vector34\n\n# Creation\n\n@docs fromList, repeat, from34, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector34 a`. There are exactly 34 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]]]}],"aliases":[{"name":"Vector34","comment":" A vector that contains exactly 34 elements ","args":["a"],"type":"Vector34.Internal.Vector34 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector34.Vector34 a -> Vector35.Internal.Vector35 a"},{"name":"foldl","comment":" Reduce a `Vector34 a` from the left. ","type":"(a -> b -> b) -> b -> Vector34.Vector34 a -> b"},{"name":"foldr","comment":" Reduce a `Vector34 a` from the right. ","type":"(a -> b -> b) -> b -> Vector34.Vector34 a -> b"},{"name":"from34","comment":" Make a `Vector34 a` from 34 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector34.Vector34 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector34 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector34.Vector34 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector34 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector34.Vector34 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector34 a` ","type":"Vector34.Index -> Vector34.Vector34 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector34 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector34.Vector34 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector34.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector34.Index -> a -> b) -> Vector34.Vector34 a -> Vector34.Vector34 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 33 ","type":"Vector34.Vector34 Vector34.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector34 a` using a function that takes an `Index` ","type":"(Vector34.Index -> a) -> Vector34.Vector34 a"},{"name":"initializeFromInt","comment":" Make a `Vector34 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector34.Vector34 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector34 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector34.Index"},{"name":"length","comment":" The length of this vector type, which is 34 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector34 a`. ","type":"(a -> b) -> Vector34.Vector34 a -> Vector34.Vector34 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector34.Vector34 a -> Vector34.Vector34 b -> Vector34.Vector34 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector34.Vector34 a -> Vector34.Vector34 b -> Vector34.Vector34 c -> Vector34.Vector34 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector34.Vector34 a -> Vector34.Vector34 b -> Vector34.Vector34 c -> Vector34.Vector34 d -> Vector34.Vector34 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector34.Vector34 a -> Vector34.Vector34 b -> Vector34.Vector34 c -> Vector34.Vector34 d -> Vector34.Vector34 e -> Vector34.Vector34 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector34.Index -> (a -> a) -> Vector34.Vector34 a -> Vector34.Vector34 a"},{"name":"member","comment":" See if a Vector34 a contains a value ","type":"a -> Vector34.Vector34 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector34.Index -> Maybe.Maybe Vector34.Index"},{"name":"pop","comment":" Separate a `Vector34 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector34.Vector34 a -> ( Vector33.Internal.Vector33 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector34.Index -> Maybe.Maybe Vector34.Index"},{"name":"push","comment":" Add an element to the end of a `Vector34 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector34.Vector34 a -> Vector35.Internal.Vector35 a"},{"name":"repeat","comment":" Make a `Vector34 a` filled with just one item repeated over and over again. ","type":"a -> Vector34.Vector34 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector34 a` ","type":"Vector34.Vector34 a -> Vector34.Vector34 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector34 a` ","type":"Vector34.Index -> a -> Vector34.Vector34 a -> Vector34.Vector34 a"},{"name":"toIndexedList","comment":" Turn a `Vector34 a` elm into a list, where each element is paired with its `Index` ","type":"Vector34.Vector34 a -> List.List ( Vector34.Index, a )"},{"name":"toList","comment":" Convert a `Vector34 a` into a `List a` of length 34 ","type":"Vector34.Vector34 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector34 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector34.Vector34 a -> ( a, Vector33.Internal.Vector33 a )"}],"binops":[]},{"name":"Vector35","comment":" A vector of length 35\n\n# Vector35\n\n@docs Vector35\n\n# Creation\n\n@docs fromList, repeat, from35, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector35 a`. There are exactly 35 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]]]}],"aliases":[{"name":"Vector35","comment":" A vector that contains exactly 35 elements ","args":["a"],"type":"Vector35.Internal.Vector35 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector35.Vector35 a -> Vector36.Internal.Vector36 a"},{"name":"foldl","comment":" Reduce a `Vector35 a` from the left. ","type":"(a -> b -> b) -> b -> Vector35.Vector35 a -> b"},{"name":"foldr","comment":" Reduce a `Vector35 a` from the right. ","type":"(a -> b -> b) -> b -> Vector35.Vector35 a -> b"},{"name":"from35","comment":" Make a `Vector35 a` from 35 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector35.Vector35 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector35 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector35.Vector35 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector35 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector35.Vector35 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector35 a` ","type":"Vector35.Index -> Vector35.Vector35 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector35 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector35.Vector35 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector35.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector35.Index -> a -> b) -> Vector35.Vector35 a -> Vector35.Vector35 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 34 ","type":"Vector35.Vector35 Vector35.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector35 a` using a function that takes an `Index` ","type":"(Vector35.Index -> a) -> Vector35.Vector35 a"},{"name":"initializeFromInt","comment":" Make a `Vector35 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector35.Vector35 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector35 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector35.Index"},{"name":"length","comment":" The length of this vector type, which is 35 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector35 a`. ","type":"(a -> b) -> Vector35.Vector35 a -> Vector35.Vector35 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector35.Vector35 a -> Vector35.Vector35 b -> Vector35.Vector35 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector35.Vector35 a -> Vector35.Vector35 b -> Vector35.Vector35 c -> Vector35.Vector35 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector35.Vector35 a -> Vector35.Vector35 b -> Vector35.Vector35 c -> Vector35.Vector35 d -> Vector35.Vector35 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector35.Vector35 a -> Vector35.Vector35 b -> Vector35.Vector35 c -> Vector35.Vector35 d -> Vector35.Vector35 e -> Vector35.Vector35 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector35.Index -> (a -> a) -> Vector35.Vector35 a -> Vector35.Vector35 a"},{"name":"member","comment":" See if a Vector35 a contains a value ","type":"a -> Vector35.Vector35 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector35.Index -> Maybe.Maybe Vector35.Index"},{"name":"pop","comment":" Separate a `Vector35 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector35.Vector35 a -> ( Vector34.Internal.Vector34 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector35.Index -> Maybe.Maybe Vector35.Index"},{"name":"push","comment":" Add an element to the end of a `Vector35 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector35.Vector35 a -> Vector36.Internal.Vector36 a"},{"name":"repeat","comment":" Make a `Vector35 a` filled with just one item repeated over and over again. ","type":"a -> Vector35.Vector35 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector35 a` ","type":"Vector35.Vector35 a -> Vector35.Vector35 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector35 a` ","type":"Vector35.Index -> a -> Vector35.Vector35 a -> Vector35.Vector35 a"},{"name":"toIndexedList","comment":" Turn a `Vector35 a` elm into a list, where each element is paired with its `Index` ","type":"Vector35.Vector35 a -> List.List ( Vector35.Index, a )"},{"name":"toList","comment":" Convert a `Vector35 a` into a `List a` of length 35 ","type":"Vector35.Vector35 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector35 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector35.Vector35 a -> ( a, Vector34.Internal.Vector34 a )"}],"binops":[]},{"name":"Vector36","comment":" A vector of length 36\n\n# Vector36\n\n@docs Vector36\n\n# Creation\n\n@docs fromList, repeat, from36, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector36 a`. There are exactly 36 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]]]}],"aliases":[{"name":"Vector36","comment":" A vector that contains exactly 36 elements ","args":["a"],"type":"Vector36.Internal.Vector36 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector36.Vector36 a -> Vector37.Internal.Vector37 a"},{"name":"foldl","comment":" Reduce a `Vector36 a` from the left. ","type":"(a -> b -> b) -> b -> Vector36.Vector36 a -> b"},{"name":"foldr","comment":" Reduce a `Vector36 a` from the right. ","type":"(a -> b -> b) -> b -> Vector36.Vector36 a -> b"},{"name":"from36","comment":" Make a `Vector36 a` from 36 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector36.Vector36 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector36 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector36.Vector36 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector36 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector36.Vector36 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector36 a` ","type":"Vector36.Index -> Vector36.Vector36 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector36 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector36.Vector36 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector36.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector36.Index -> a -> b) -> Vector36.Vector36 a -> Vector36.Vector36 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 35 ","type":"Vector36.Vector36 Vector36.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector36 a` using a function that takes an `Index` ","type":"(Vector36.Index -> a) -> Vector36.Vector36 a"},{"name":"initializeFromInt","comment":" Make a `Vector36 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector36.Vector36 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector36 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector36.Index"},{"name":"length","comment":" The length of this vector type, which is 36 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector36 a`. ","type":"(a -> b) -> Vector36.Vector36 a -> Vector36.Vector36 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector36.Vector36 a -> Vector36.Vector36 b -> Vector36.Vector36 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector36.Vector36 a -> Vector36.Vector36 b -> Vector36.Vector36 c -> Vector36.Vector36 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector36.Vector36 a -> Vector36.Vector36 b -> Vector36.Vector36 c -> Vector36.Vector36 d -> Vector36.Vector36 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector36.Vector36 a -> Vector36.Vector36 b -> Vector36.Vector36 c -> Vector36.Vector36 d -> Vector36.Vector36 e -> Vector36.Vector36 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector36.Index -> (a -> a) -> Vector36.Vector36 a -> Vector36.Vector36 a"},{"name":"member","comment":" See if a Vector36 a contains a value ","type":"a -> Vector36.Vector36 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector36.Index -> Maybe.Maybe Vector36.Index"},{"name":"pop","comment":" Separate a `Vector36 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector36.Vector36 a -> ( Vector35.Internal.Vector35 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector36.Index -> Maybe.Maybe Vector36.Index"},{"name":"push","comment":" Add an element to the end of a `Vector36 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector36.Vector36 a -> Vector37.Internal.Vector37 a"},{"name":"repeat","comment":" Make a `Vector36 a` filled with just one item repeated over and over again. ","type":"a -> Vector36.Vector36 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector36 a` ","type":"Vector36.Vector36 a -> Vector36.Vector36 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector36 a` ","type":"Vector36.Index -> a -> Vector36.Vector36 a -> Vector36.Vector36 a"},{"name":"toIndexedList","comment":" Turn a `Vector36 a` elm into a list, where each element is paired with its `Index` ","type":"Vector36.Vector36 a -> List.List ( Vector36.Index, a )"},{"name":"toList","comment":" Convert a `Vector36 a` into a `List a` of length 36 ","type":"Vector36.Vector36 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector36 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector36.Vector36 a -> ( a, Vector35.Internal.Vector35 a )"}],"binops":[]},{"name":"Vector37","comment":" A vector of length 37\n\n# Vector37\n\n@docs Vector37\n\n# Creation\n\n@docs fromList, repeat, from37, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector37 a`. There are exactly 37 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]]]}],"aliases":[{"name":"Vector37","comment":" A vector that contains exactly 37 elements ","args":["a"],"type":"Vector37.Internal.Vector37 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector37.Vector37 a -> Vector38.Internal.Vector38 a"},{"name":"foldl","comment":" Reduce a `Vector37 a` from the left. ","type":"(a -> b -> b) -> b -> Vector37.Vector37 a -> b"},{"name":"foldr","comment":" Reduce a `Vector37 a` from the right. ","type":"(a -> b -> b) -> b -> Vector37.Vector37 a -> b"},{"name":"from37","comment":" Make a `Vector37 a` from 37 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector37.Vector37 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector37 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector37.Vector37 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector37 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector37.Vector37 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector37 a` ","type":"Vector37.Index -> Vector37.Vector37 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector37 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector37.Vector37 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector37.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector37.Index -> a -> b) -> Vector37.Vector37 a -> Vector37.Vector37 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 36 ","type":"Vector37.Vector37 Vector37.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector37 a` using a function that takes an `Index` ","type":"(Vector37.Index -> a) -> Vector37.Vector37 a"},{"name":"initializeFromInt","comment":" Make a `Vector37 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector37.Vector37 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector37 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector37.Index"},{"name":"length","comment":" The length of this vector type, which is 37 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector37 a`. ","type":"(a -> b) -> Vector37.Vector37 a -> Vector37.Vector37 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector37.Vector37 a -> Vector37.Vector37 b -> Vector37.Vector37 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector37.Vector37 a -> Vector37.Vector37 b -> Vector37.Vector37 c -> Vector37.Vector37 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector37.Vector37 a -> Vector37.Vector37 b -> Vector37.Vector37 c -> Vector37.Vector37 d -> Vector37.Vector37 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector37.Vector37 a -> Vector37.Vector37 b -> Vector37.Vector37 c -> Vector37.Vector37 d -> Vector37.Vector37 e -> Vector37.Vector37 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector37.Index -> (a -> a) -> Vector37.Vector37 a -> Vector37.Vector37 a"},{"name":"member","comment":" See if a Vector37 a contains a value ","type":"a -> Vector37.Vector37 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector37.Index -> Maybe.Maybe Vector37.Index"},{"name":"pop","comment":" Separate a `Vector37 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector37.Vector37 a -> ( Vector36.Internal.Vector36 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector37.Index -> Maybe.Maybe Vector37.Index"},{"name":"push","comment":" Add an element to the end of a `Vector37 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector37.Vector37 a -> Vector38.Internal.Vector38 a"},{"name":"repeat","comment":" Make a `Vector37 a` filled with just one item repeated over and over again. ","type":"a -> Vector37.Vector37 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector37 a` ","type":"Vector37.Vector37 a -> Vector37.Vector37 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector37 a` ","type":"Vector37.Index -> a -> Vector37.Vector37 a -> Vector37.Vector37 a"},{"name":"toIndexedList","comment":" Turn a `Vector37 a` elm into a list, where each element is paired with its `Index` ","type":"Vector37.Vector37 a -> List.List ( Vector37.Index, a )"},{"name":"toList","comment":" Convert a `Vector37 a` into a `List a` of length 37 ","type":"Vector37.Vector37 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector37 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector37.Vector37 a -> ( a, Vector36.Internal.Vector36 a )"}],"binops":[]},{"name":"Vector38","comment":" A vector of length 38\n\n# Vector38\n\n@docs Vector38\n\n# Creation\n\n@docs fromList, repeat, from38, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector38 a`. There are exactly 38 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]]]}],"aliases":[{"name":"Vector38","comment":" A vector that contains exactly 38 elements ","args":["a"],"type":"Vector38.Internal.Vector38 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector38.Vector38 a -> Vector39.Internal.Vector39 a"},{"name":"foldl","comment":" Reduce a `Vector38 a` from the left. ","type":"(a -> b -> b) -> b -> Vector38.Vector38 a -> b"},{"name":"foldr","comment":" Reduce a `Vector38 a` from the right. ","type":"(a -> b -> b) -> b -> Vector38.Vector38 a -> b"},{"name":"from38","comment":" Make a `Vector38 a` from 38 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector38.Vector38 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector38 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector38.Vector38 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector38 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector38.Vector38 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector38 a` ","type":"Vector38.Index -> Vector38.Vector38 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector38 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector38.Vector38 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector38.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector38.Index -> a -> b) -> Vector38.Vector38 a -> Vector38.Vector38 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 37 ","type":"Vector38.Vector38 Vector38.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector38 a` using a function that takes an `Index` ","type":"(Vector38.Index -> a) -> Vector38.Vector38 a"},{"name":"initializeFromInt","comment":" Make a `Vector38 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector38.Vector38 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector38 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector38.Index"},{"name":"length","comment":" The length of this vector type, which is 38 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector38 a`. ","type":"(a -> b) -> Vector38.Vector38 a -> Vector38.Vector38 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector38.Vector38 a -> Vector38.Vector38 b -> Vector38.Vector38 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector38.Vector38 a -> Vector38.Vector38 b -> Vector38.Vector38 c -> Vector38.Vector38 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector38.Vector38 a -> Vector38.Vector38 b -> Vector38.Vector38 c -> Vector38.Vector38 d -> Vector38.Vector38 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector38.Vector38 a -> Vector38.Vector38 b -> Vector38.Vector38 c -> Vector38.Vector38 d -> Vector38.Vector38 e -> Vector38.Vector38 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector38.Index -> (a -> a) -> Vector38.Vector38 a -> Vector38.Vector38 a"},{"name":"member","comment":" See if a Vector38 a contains a value ","type":"a -> Vector38.Vector38 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector38.Index -> Maybe.Maybe Vector38.Index"},{"name":"pop","comment":" Separate a `Vector38 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector38.Vector38 a -> ( Vector37.Internal.Vector37 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector38.Index -> Maybe.Maybe Vector38.Index"},{"name":"push","comment":" Add an element to the end of a `Vector38 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector38.Vector38 a -> Vector39.Internal.Vector39 a"},{"name":"repeat","comment":" Make a `Vector38 a` filled with just one item repeated over and over again. ","type":"a -> Vector38.Vector38 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector38 a` ","type":"Vector38.Vector38 a -> Vector38.Vector38 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector38 a` ","type":"Vector38.Index -> a -> Vector38.Vector38 a -> Vector38.Vector38 a"},{"name":"toIndexedList","comment":" Turn a `Vector38 a` elm into a list, where each element is paired with its `Index` ","type":"Vector38.Vector38 a -> List.List ( Vector38.Index, a )"},{"name":"toList","comment":" Convert a `Vector38 a` into a `List a` of length 38 ","type":"Vector38.Vector38 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector38 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector38.Vector38 a -> ( a, Vector37.Internal.Vector37 a )"}],"binops":[]},{"name":"Vector39","comment":" A vector of length 39\n\n# Vector39\n\n@docs Vector39\n\n# Creation\n\n@docs fromList, repeat, from39, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector39 a`. There are exactly 39 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]]]}],"aliases":[{"name":"Vector39","comment":" A vector that contains exactly 39 elements ","args":["a"],"type":"Vector39.Internal.Vector39 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector39.Vector39 a -> Vector40.Internal.Vector40 a"},{"name":"foldl","comment":" Reduce a `Vector39 a` from the left. ","type":"(a -> b -> b) -> b -> Vector39.Vector39 a -> b"},{"name":"foldr","comment":" Reduce a `Vector39 a` from the right. ","type":"(a -> b -> b) -> b -> Vector39.Vector39 a -> b"},{"name":"from39","comment":" Make a `Vector39 a` from 39 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector39.Vector39 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector39 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector39.Vector39 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector39 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector39.Vector39 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector39 a` ","type":"Vector39.Index -> Vector39.Vector39 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector39 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector39.Vector39 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector39.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector39.Index -> a -> b) -> Vector39.Vector39 a -> Vector39.Vector39 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 38 ","type":"Vector39.Vector39 Vector39.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector39 a` using a function that takes an `Index` ","type":"(Vector39.Index -> a) -> Vector39.Vector39 a"},{"name":"initializeFromInt","comment":" Make a `Vector39 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector39.Vector39 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector39 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector39.Index"},{"name":"length","comment":" The length of this vector type, which is 39 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector39 a`. ","type":"(a -> b) -> Vector39.Vector39 a -> Vector39.Vector39 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector39.Vector39 a -> Vector39.Vector39 b -> Vector39.Vector39 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector39.Vector39 a -> Vector39.Vector39 b -> Vector39.Vector39 c -> Vector39.Vector39 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector39.Vector39 a -> Vector39.Vector39 b -> Vector39.Vector39 c -> Vector39.Vector39 d -> Vector39.Vector39 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector39.Vector39 a -> Vector39.Vector39 b -> Vector39.Vector39 c -> Vector39.Vector39 d -> Vector39.Vector39 e -> Vector39.Vector39 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector39.Index -> (a -> a) -> Vector39.Vector39 a -> Vector39.Vector39 a"},{"name":"member","comment":" See if a Vector39 a contains a value ","type":"a -> Vector39.Vector39 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector39.Index -> Maybe.Maybe Vector39.Index"},{"name":"pop","comment":" Separate a `Vector39 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector39.Vector39 a -> ( Vector38.Internal.Vector38 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector39.Index -> Maybe.Maybe Vector39.Index"},{"name":"push","comment":" Add an element to the end of a `Vector39 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector39.Vector39 a -> Vector40.Internal.Vector40 a"},{"name":"repeat","comment":" Make a `Vector39 a` filled with just one item repeated over and over again. ","type":"a -> Vector39.Vector39 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector39 a` ","type":"Vector39.Vector39 a -> Vector39.Vector39 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector39 a` ","type":"Vector39.Index -> a -> Vector39.Vector39 a -> Vector39.Vector39 a"},{"name":"toIndexedList","comment":" Turn a `Vector39 a` elm into a list, where each element is paired with its `Index` ","type":"Vector39.Vector39 a -> List.List ( Vector39.Index, a )"},{"name":"toList","comment":" Convert a `Vector39 a` into a `List a` of length 39 ","type":"Vector39.Vector39 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector39 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector39.Vector39 a -> ( a, Vector38.Internal.Vector38 a )"}],"binops":[]},{"name":"Vector4","comment":" A vector of length 4\n\n# Vector4\n\n@docs Vector4\n\n# Creation\n\n@docs fromList, repeat, from4, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector4 a`. There are exactly 4 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]]]}],"aliases":[{"name":"Vector4","comment":" A vector that contains exactly 4 elements ","args":["a"],"type":"Vector4.Internal.Vector4 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector4.Vector4 a -> Vector5.Internal.Vector5 a"},{"name":"foldl","comment":" Reduce a `Vector4 a` from the left. ","type":"(a -> b -> b) -> b -> Vector4.Vector4 a -> b"},{"name":"foldr","comment":" Reduce a `Vector4 a` from the right. ","type":"(a -> b -> b) -> b -> Vector4.Vector4 a -> b"},{"name":"from4","comment":" Make a `Vector4 a` from 4 elements ","type":"a -> a -> a -> a -> Vector4.Vector4 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector4 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector4.Vector4 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector4 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector4.Vector4 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector4 a` ","type":"Vector4.Index -> Vector4.Vector4 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector4 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector4.Vector4 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector4.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector4.Index -> a -> b) -> Vector4.Vector4 a -> Vector4.Vector4 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 3 ","type":"Vector4.Vector4 Vector4.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector4 a` using a function that takes an `Index` ","type":"(Vector4.Index -> a) -> Vector4.Vector4 a"},{"name":"initializeFromInt","comment":" Make a `Vector4 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector4.Vector4 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector4 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector4.Index"},{"name":"length","comment":" The length of this vector type, which is 4 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector4 a`. ","type":"(a -> b) -> Vector4.Vector4 a -> Vector4.Vector4 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector4.Vector4 a -> Vector4.Vector4 b -> Vector4.Vector4 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector4.Vector4 a -> Vector4.Vector4 b -> Vector4.Vector4 c -> Vector4.Vector4 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector4.Vector4 a -> Vector4.Vector4 b -> Vector4.Vector4 c -> Vector4.Vector4 d -> Vector4.Vector4 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector4.Vector4 a -> Vector4.Vector4 b -> Vector4.Vector4 c -> Vector4.Vector4 d -> Vector4.Vector4 e -> Vector4.Vector4 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector4.Index -> (a -> a) -> Vector4.Vector4 a -> Vector4.Vector4 a"},{"name":"member","comment":" See if a Vector4 a contains a value ","type":"a -> Vector4.Vector4 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector4.Index -> Maybe.Maybe Vector4.Index"},{"name":"pop","comment":" Separate a `Vector4 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector4.Vector4 a -> ( Vector3.Internal.Vector3 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector4.Index -> Maybe.Maybe Vector4.Index"},{"name":"push","comment":" Add an element to the end of a `Vector4 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector4.Vector4 a -> Vector5.Internal.Vector5 a"},{"name":"repeat","comment":" Make a `Vector4 a` filled with just one item repeated over and over again. ","type":"a -> Vector4.Vector4 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector4 a` ","type":"Vector4.Vector4 a -> Vector4.Vector4 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector4 a` ","type":"Vector4.Index -> a -> Vector4.Vector4 a -> Vector4.Vector4 a"},{"name":"toIndexedList","comment":" Turn a `Vector4 a` elm into a list, where each element is paired with its `Index` ","type":"Vector4.Vector4 a -> List.List ( Vector4.Index, a )"},{"name":"toList","comment":" Convert a `Vector4 a` into a `List a` of length 4 ","type":"Vector4.Vector4 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector4 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector4.Vector4 a -> ( a, Vector3.Internal.Vector3 a )"}],"binops":[]},{"name":"Vector40","comment":" A vector of length 40\n\n# Vector40\n\n@docs Vector40\n\n# Creation\n\n@docs fromList, repeat, from40, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector40 a`. There are exactly 40 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]]]}],"aliases":[{"name":"Vector40","comment":" A vector that contains exactly 40 elements ","args":["a"],"type":"Vector40.Internal.Vector40 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector40.Vector40 a -> Vector41.Internal.Vector41 a"},{"name":"foldl","comment":" Reduce a `Vector40 a` from the left. ","type":"(a -> b -> b) -> b -> Vector40.Vector40 a -> b"},{"name":"foldr","comment":" Reduce a `Vector40 a` from the right. ","type":"(a -> b -> b) -> b -> Vector40.Vector40 a -> b"},{"name":"from40","comment":" Make a `Vector40 a` from 40 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector40.Vector40 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector40 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector40.Vector40 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector40 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector40.Vector40 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector40 a` ","type":"Vector40.Index -> Vector40.Vector40 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector40 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector40.Vector40 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector40.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector40.Index -> a -> b) -> Vector40.Vector40 a -> Vector40.Vector40 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 39 ","type":"Vector40.Vector40 Vector40.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector40 a` using a function that takes an `Index` ","type":"(Vector40.Index -> a) -> Vector40.Vector40 a"},{"name":"initializeFromInt","comment":" Make a `Vector40 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector40.Vector40 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector40 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector40.Index"},{"name":"length","comment":" The length of this vector type, which is 40 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector40 a`. ","type":"(a -> b) -> Vector40.Vector40 a -> Vector40.Vector40 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector40.Vector40 a -> Vector40.Vector40 b -> Vector40.Vector40 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector40.Vector40 a -> Vector40.Vector40 b -> Vector40.Vector40 c -> Vector40.Vector40 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector40.Vector40 a -> Vector40.Vector40 b -> Vector40.Vector40 c -> Vector40.Vector40 d -> Vector40.Vector40 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector40.Vector40 a -> Vector40.Vector40 b -> Vector40.Vector40 c -> Vector40.Vector40 d -> Vector40.Vector40 e -> Vector40.Vector40 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector40.Index -> (a -> a) -> Vector40.Vector40 a -> Vector40.Vector40 a"},{"name":"member","comment":" See if a Vector40 a contains a value ","type":"a -> Vector40.Vector40 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector40.Index -> Maybe.Maybe Vector40.Index"},{"name":"pop","comment":" Separate a `Vector40 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector40.Vector40 a -> ( Vector39.Internal.Vector39 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector40.Index -> Maybe.Maybe Vector40.Index"},{"name":"push","comment":" Add an element to the end of a `Vector40 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector40.Vector40 a -> Vector41.Internal.Vector41 a"},{"name":"repeat","comment":" Make a `Vector40 a` filled with just one item repeated over and over again. ","type":"a -> Vector40.Vector40 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector40 a` ","type":"Vector40.Vector40 a -> Vector40.Vector40 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector40 a` ","type":"Vector40.Index -> a -> Vector40.Vector40 a -> Vector40.Vector40 a"},{"name":"toIndexedList","comment":" Turn a `Vector40 a` elm into a list, where each element is paired with its `Index` ","type":"Vector40.Vector40 a -> List.List ( Vector40.Index, a )"},{"name":"toList","comment":" Convert a `Vector40 a` into a `List a` of length 40 ","type":"Vector40.Vector40 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector40 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector40.Vector40 a -> ( a, Vector39.Internal.Vector39 a )"}],"binops":[]},{"name":"Vector41","comment":" A vector of length 41\n\n# Vector41\n\n@docs Vector41\n\n# Creation\n\n@docs fromList, repeat, from41, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector41 a`. There are exactly 41 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]]]}],"aliases":[{"name":"Vector41","comment":" A vector that contains exactly 41 elements ","args":["a"],"type":"Vector41.Internal.Vector41 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector41.Vector41 a -> Vector42.Internal.Vector42 a"},{"name":"foldl","comment":" Reduce a `Vector41 a` from the left. ","type":"(a -> b -> b) -> b -> Vector41.Vector41 a -> b"},{"name":"foldr","comment":" Reduce a `Vector41 a` from the right. ","type":"(a -> b -> b) -> b -> Vector41.Vector41 a -> b"},{"name":"from41","comment":" Make a `Vector41 a` from 41 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector41.Vector41 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector41 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector41.Vector41 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector41 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector41.Vector41 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector41 a` ","type":"Vector41.Index -> Vector41.Vector41 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector41 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector41.Vector41 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector41.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector41.Index -> a -> b) -> Vector41.Vector41 a -> Vector41.Vector41 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 40 ","type":"Vector41.Vector41 Vector41.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector41 a` using a function that takes an `Index` ","type":"(Vector41.Index -> a) -> Vector41.Vector41 a"},{"name":"initializeFromInt","comment":" Make a `Vector41 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector41.Vector41 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector41 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector41.Index"},{"name":"length","comment":" The length of this vector type, which is 41 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector41 a`. ","type":"(a -> b) -> Vector41.Vector41 a -> Vector41.Vector41 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector41.Vector41 a -> Vector41.Vector41 b -> Vector41.Vector41 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector41.Vector41 a -> Vector41.Vector41 b -> Vector41.Vector41 c -> Vector41.Vector41 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector41.Vector41 a -> Vector41.Vector41 b -> Vector41.Vector41 c -> Vector41.Vector41 d -> Vector41.Vector41 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector41.Vector41 a -> Vector41.Vector41 b -> Vector41.Vector41 c -> Vector41.Vector41 d -> Vector41.Vector41 e -> Vector41.Vector41 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector41.Index -> (a -> a) -> Vector41.Vector41 a -> Vector41.Vector41 a"},{"name":"member","comment":" See if a Vector41 a contains a value ","type":"a -> Vector41.Vector41 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector41.Index -> Maybe.Maybe Vector41.Index"},{"name":"pop","comment":" Separate a `Vector41 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector41.Vector41 a -> ( Vector40.Internal.Vector40 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector41.Index -> Maybe.Maybe Vector41.Index"},{"name":"push","comment":" Add an element to the end of a `Vector41 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector41.Vector41 a -> Vector42.Internal.Vector42 a"},{"name":"repeat","comment":" Make a `Vector41 a` filled with just one item repeated over and over again. ","type":"a -> Vector41.Vector41 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector41 a` ","type":"Vector41.Vector41 a -> Vector41.Vector41 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector41 a` ","type":"Vector41.Index -> a -> Vector41.Vector41 a -> Vector41.Vector41 a"},{"name":"toIndexedList","comment":" Turn a `Vector41 a` elm into a list, where each element is paired with its `Index` ","type":"Vector41.Vector41 a -> List.List ( Vector41.Index, a )"},{"name":"toList","comment":" Convert a `Vector41 a` into a `List a` of length 41 ","type":"Vector41.Vector41 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector41 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector41.Vector41 a -> ( a, Vector40.Internal.Vector40 a )"}],"binops":[]},{"name":"Vector42","comment":" A vector of length 42\n\n# Vector42\n\n@docs Vector42\n\n# Creation\n\n@docs fromList, repeat, from42, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector42 a`. There are exactly 42 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]]]}],"aliases":[{"name":"Vector42","comment":" A vector that contains exactly 42 elements ","args":["a"],"type":"Vector42.Internal.Vector42 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector42.Vector42 a -> Vector43.Internal.Vector43 a"},{"name":"foldl","comment":" Reduce a `Vector42 a` from the left. ","type":"(a -> b -> b) -> b -> Vector42.Vector42 a -> b"},{"name":"foldr","comment":" Reduce a `Vector42 a` from the right. ","type":"(a -> b -> b) -> b -> Vector42.Vector42 a -> b"},{"name":"from42","comment":" Make a `Vector42 a` from 42 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector42.Vector42 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector42 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector42.Vector42 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector42 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector42.Vector42 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector42 a` ","type":"Vector42.Index -> Vector42.Vector42 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector42 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector42.Vector42 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector42.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector42.Index -> a -> b) -> Vector42.Vector42 a -> Vector42.Vector42 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 41 ","type":"Vector42.Vector42 Vector42.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector42 a` using a function that takes an `Index` ","type":"(Vector42.Index -> a) -> Vector42.Vector42 a"},{"name":"initializeFromInt","comment":" Make a `Vector42 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector42.Vector42 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector42 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector42.Index"},{"name":"length","comment":" The length of this vector type, which is 42 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector42 a`. ","type":"(a -> b) -> Vector42.Vector42 a -> Vector42.Vector42 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector42.Vector42 a -> Vector42.Vector42 b -> Vector42.Vector42 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector42.Vector42 a -> Vector42.Vector42 b -> Vector42.Vector42 c -> Vector42.Vector42 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector42.Vector42 a -> Vector42.Vector42 b -> Vector42.Vector42 c -> Vector42.Vector42 d -> Vector42.Vector42 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector42.Vector42 a -> Vector42.Vector42 b -> Vector42.Vector42 c -> Vector42.Vector42 d -> Vector42.Vector42 e -> Vector42.Vector42 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector42.Index -> (a -> a) -> Vector42.Vector42 a -> Vector42.Vector42 a"},{"name":"member","comment":" See if a Vector42 a contains a value ","type":"a -> Vector42.Vector42 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector42.Index -> Maybe.Maybe Vector42.Index"},{"name":"pop","comment":" Separate a `Vector42 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector42.Vector42 a -> ( Vector41.Internal.Vector41 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector42.Index -> Maybe.Maybe Vector42.Index"},{"name":"push","comment":" Add an element to the end of a `Vector42 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector42.Vector42 a -> Vector43.Internal.Vector43 a"},{"name":"repeat","comment":" Make a `Vector42 a` filled with just one item repeated over and over again. ","type":"a -> Vector42.Vector42 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector42 a` ","type":"Vector42.Vector42 a -> Vector42.Vector42 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector42 a` ","type":"Vector42.Index -> a -> Vector42.Vector42 a -> Vector42.Vector42 a"},{"name":"toIndexedList","comment":" Turn a `Vector42 a` elm into a list, where each element is paired with its `Index` ","type":"Vector42.Vector42 a -> List.List ( Vector42.Index, a )"},{"name":"toList","comment":" Convert a `Vector42 a` into a `List a` of length 42 ","type":"Vector42.Vector42 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector42 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector42.Vector42 a -> ( a, Vector41.Internal.Vector41 a )"}],"binops":[]},{"name":"Vector43","comment":" A vector of length 43\n\n# Vector43\n\n@docs Vector43\n\n# Creation\n\n@docs fromList, repeat, from43, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector43 a`. There are exactly 43 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]]]}],"aliases":[{"name":"Vector43","comment":" A vector that contains exactly 43 elements ","args":["a"],"type":"Vector43.Internal.Vector43 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector43.Vector43 a -> Vector44.Internal.Vector44 a"},{"name":"foldl","comment":" Reduce a `Vector43 a` from the left. ","type":"(a -> b -> b) -> b -> Vector43.Vector43 a -> b"},{"name":"foldr","comment":" Reduce a `Vector43 a` from the right. ","type":"(a -> b -> b) -> b -> Vector43.Vector43 a -> b"},{"name":"from43","comment":" Make a `Vector43 a` from 43 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector43.Vector43 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector43 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector43.Vector43 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector43 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector43.Vector43 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector43 a` ","type":"Vector43.Index -> Vector43.Vector43 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector43 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector43.Vector43 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector43.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector43.Index -> a -> b) -> Vector43.Vector43 a -> Vector43.Vector43 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 42 ","type":"Vector43.Vector43 Vector43.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector43 a` using a function that takes an `Index` ","type":"(Vector43.Index -> a) -> Vector43.Vector43 a"},{"name":"initializeFromInt","comment":" Make a `Vector43 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector43.Vector43 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector43 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector43.Index"},{"name":"length","comment":" The length of this vector type, which is 43 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector43 a`. ","type":"(a -> b) -> Vector43.Vector43 a -> Vector43.Vector43 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector43.Vector43 a -> Vector43.Vector43 b -> Vector43.Vector43 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector43.Vector43 a -> Vector43.Vector43 b -> Vector43.Vector43 c -> Vector43.Vector43 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector43.Vector43 a -> Vector43.Vector43 b -> Vector43.Vector43 c -> Vector43.Vector43 d -> Vector43.Vector43 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector43.Vector43 a -> Vector43.Vector43 b -> Vector43.Vector43 c -> Vector43.Vector43 d -> Vector43.Vector43 e -> Vector43.Vector43 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector43.Index -> (a -> a) -> Vector43.Vector43 a -> Vector43.Vector43 a"},{"name":"member","comment":" See if a Vector43 a contains a value ","type":"a -> Vector43.Vector43 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector43.Index -> Maybe.Maybe Vector43.Index"},{"name":"pop","comment":" Separate a `Vector43 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector43.Vector43 a -> ( Vector42.Internal.Vector42 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector43.Index -> Maybe.Maybe Vector43.Index"},{"name":"push","comment":" Add an element to the end of a `Vector43 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector43.Vector43 a -> Vector44.Internal.Vector44 a"},{"name":"repeat","comment":" Make a `Vector43 a` filled with just one item repeated over and over again. ","type":"a -> Vector43.Vector43 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector43 a` ","type":"Vector43.Vector43 a -> Vector43.Vector43 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector43 a` ","type":"Vector43.Index -> a -> Vector43.Vector43 a -> Vector43.Vector43 a"},{"name":"toIndexedList","comment":" Turn a `Vector43 a` elm into a list, where each element is paired with its `Index` ","type":"Vector43.Vector43 a -> List.List ( Vector43.Index, a )"},{"name":"toList","comment":" Convert a `Vector43 a` into a `List a` of length 43 ","type":"Vector43.Vector43 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector43 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector43.Vector43 a -> ( a, Vector42.Internal.Vector42 a )"}],"binops":[]},{"name":"Vector44","comment":" A vector of length 44\n\n# Vector44\n\n@docs Vector44\n\n# Creation\n\n@docs fromList, repeat, from44, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector44 a`. There are exactly 44 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]]]}],"aliases":[{"name":"Vector44","comment":" A vector that contains exactly 44 elements ","args":["a"],"type":"Vector44.Internal.Vector44 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector44.Vector44 a -> Vector45.Internal.Vector45 a"},{"name":"foldl","comment":" Reduce a `Vector44 a` from the left. ","type":"(a -> b -> b) -> b -> Vector44.Vector44 a -> b"},{"name":"foldr","comment":" Reduce a `Vector44 a` from the right. ","type":"(a -> b -> b) -> b -> Vector44.Vector44 a -> b"},{"name":"from44","comment":" Make a `Vector44 a` from 44 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector44.Vector44 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector44 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector44.Vector44 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector44 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector44.Vector44 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector44 a` ","type":"Vector44.Index -> Vector44.Vector44 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector44 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector44.Vector44 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector44.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector44.Index -> a -> b) -> Vector44.Vector44 a -> Vector44.Vector44 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 43 ","type":"Vector44.Vector44 Vector44.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector44 a` using a function that takes an `Index` ","type":"(Vector44.Index -> a) -> Vector44.Vector44 a"},{"name":"initializeFromInt","comment":" Make a `Vector44 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector44.Vector44 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector44 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector44.Index"},{"name":"length","comment":" The length of this vector type, which is 44 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector44 a`. ","type":"(a -> b) -> Vector44.Vector44 a -> Vector44.Vector44 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector44.Vector44 a -> Vector44.Vector44 b -> Vector44.Vector44 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector44.Vector44 a -> Vector44.Vector44 b -> Vector44.Vector44 c -> Vector44.Vector44 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector44.Vector44 a -> Vector44.Vector44 b -> Vector44.Vector44 c -> Vector44.Vector44 d -> Vector44.Vector44 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector44.Vector44 a -> Vector44.Vector44 b -> Vector44.Vector44 c -> Vector44.Vector44 d -> Vector44.Vector44 e -> Vector44.Vector44 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector44.Index -> (a -> a) -> Vector44.Vector44 a -> Vector44.Vector44 a"},{"name":"member","comment":" See if a Vector44 a contains a value ","type":"a -> Vector44.Vector44 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector44.Index -> Maybe.Maybe Vector44.Index"},{"name":"pop","comment":" Separate a `Vector44 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector44.Vector44 a -> ( Vector43.Internal.Vector43 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector44.Index -> Maybe.Maybe Vector44.Index"},{"name":"push","comment":" Add an element to the end of a `Vector44 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector44.Vector44 a -> Vector45.Internal.Vector45 a"},{"name":"repeat","comment":" Make a `Vector44 a` filled with just one item repeated over and over again. ","type":"a -> Vector44.Vector44 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector44 a` ","type":"Vector44.Vector44 a -> Vector44.Vector44 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector44 a` ","type":"Vector44.Index -> a -> Vector44.Vector44 a -> Vector44.Vector44 a"},{"name":"toIndexedList","comment":" Turn a `Vector44 a` elm into a list, where each element is paired with its `Index` ","type":"Vector44.Vector44 a -> List.List ( Vector44.Index, a )"},{"name":"toList","comment":" Convert a `Vector44 a` into a `List a` of length 44 ","type":"Vector44.Vector44 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector44 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector44.Vector44 a -> ( a, Vector43.Internal.Vector43 a )"}],"binops":[]},{"name":"Vector45","comment":" A vector of length 45\n\n# Vector45\n\n@docs Vector45\n\n# Creation\n\n@docs fromList, repeat, from45, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector45 a`. There are exactly 45 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]]]}],"aliases":[{"name":"Vector45","comment":" A vector that contains exactly 45 elements ","args":["a"],"type":"Vector45.Internal.Vector45 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector45.Vector45 a -> Vector46.Internal.Vector46 a"},{"name":"foldl","comment":" Reduce a `Vector45 a` from the left. ","type":"(a -> b -> b) -> b -> Vector45.Vector45 a -> b"},{"name":"foldr","comment":" Reduce a `Vector45 a` from the right. ","type":"(a -> b -> b) -> b -> Vector45.Vector45 a -> b"},{"name":"from45","comment":" Make a `Vector45 a` from 45 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector45.Vector45 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector45 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector45.Vector45 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector45 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector45.Vector45 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector45 a` ","type":"Vector45.Index -> Vector45.Vector45 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector45 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector45.Vector45 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector45.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector45.Index -> a -> b) -> Vector45.Vector45 a -> Vector45.Vector45 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 44 ","type":"Vector45.Vector45 Vector45.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector45 a` using a function that takes an `Index` ","type":"(Vector45.Index -> a) -> Vector45.Vector45 a"},{"name":"initializeFromInt","comment":" Make a `Vector45 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector45.Vector45 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector45 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector45.Index"},{"name":"length","comment":" The length of this vector type, which is 45 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector45 a`. ","type":"(a -> b) -> Vector45.Vector45 a -> Vector45.Vector45 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector45.Vector45 a -> Vector45.Vector45 b -> Vector45.Vector45 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector45.Vector45 a -> Vector45.Vector45 b -> Vector45.Vector45 c -> Vector45.Vector45 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector45.Vector45 a -> Vector45.Vector45 b -> Vector45.Vector45 c -> Vector45.Vector45 d -> Vector45.Vector45 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector45.Vector45 a -> Vector45.Vector45 b -> Vector45.Vector45 c -> Vector45.Vector45 d -> Vector45.Vector45 e -> Vector45.Vector45 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector45.Index -> (a -> a) -> Vector45.Vector45 a -> Vector45.Vector45 a"},{"name":"member","comment":" See if a Vector45 a contains a value ","type":"a -> Vector45.Vector45 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector45.Index -> Maybe.Maybe Vector45.Index"},{"name":"pop","comment":" Separate a `Vector45 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector45.Vector45 a -> ( Vector44.Internal.Vector44 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector45.Index -> Maybe.Maybe Vector45.Index"},{"name":"push","comment":" Add an element to the end of a `Vector45 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector45.Vector45 a -> Vector46.Internal.Vector46 a"},{"name":"repeat","comment":" Make a `Vector45 a` filled with just one item repeated over and over again. ","type":"a -> Vector45.Vector45 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector45 a` ","type":"Vector45.Vector45 a -> Vector45.Vector45 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector45 a` ","type":"Vector45.Index -> a -> Vector45.Vector45 a -> Vector45.Vector45 a"},{"name":"toIndexedList","comment":" Turn a `Vector45 a` elm into a list, where each element is paired with its `Index` ","type":"Vector45.Vector45 a -> List.List ( Vector45.Index, a )"},{"name":"toList","comment":" Convert a `Vector45 a` into a `List a` of length 45 ","type":"Vector45.Vector45 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector45 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector45.Vector45 a -> ( a, Vector44.Internal.Vector44 a )"}],"binops":[]},{"name":"Vector46","comment":" A vector of length 46\n\n# Vector46\n\n@docs Vector46\n\n# Creation\n\n@docs fromList, repeat, from46, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector46 a`. There are exactly 46 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]]]}],"aliases":[{"name":"Vector46","comment":" A vector that contains exactly 46 elements ","args":["a"],"type":"Vector46.Internal.Vector46 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector46.Vector46 a -> Vector47.Internal.Vector47 a"},{"name":"foldl","comment":" Reduce a `Vector46 a` from the left. ","type":"(a -> b -> b) -> b -> Vector46.Vector46 a -> b"},{"name":"foldr","comment":" Reduce a `Vector46 a` from the right. ","type":"(a -> b -> b) -> b -> Vector46.Vector46 a -> b"},{"name":"from46","comment":" Make a `Vector46 a` from 46 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector46.Vector46 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector46 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector46.Vector46 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector46 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector46.Vector46 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector46 a` ","type":"Vector46.Index -> Vector46.Vector46 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector46 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector46.Vector46 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector46.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector46.Index -> a -> b) -> Vector46.Vector46 a -> Vector46.Vector46 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 45 ","type":"Vector46.Vector46 Vector46.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector46 a` using a function that takes an `Index` ","type":"(Vector46.Index -> a) -> Vector46.Vector46 a"},{"name":"initializeFromInt","comment":" Make a `Vector46 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector46.Vector46 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector46 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector46.Index"},{"name":"length","comment":" The length of this vector type, which is 46 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector46 a`. ","type":"(a -> b) -> Vector46.Vector46 a -> Vector46.Vector46 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector46.Vector46 a -> Vector46.Vector46 b -> Vector46.Vector46 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector46.Vector46 a -> Vector46.Vector46 b -> Vector46.Vector46 c -> Vector46.Vector46 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector46.Vector46 a -> Vector46.Vector46 b -> Vector46.Vector46 c -> Vector46.Vector46 d -> Vector46.Vector46 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector46.Vector46 a -> Vector46.Vector46 b -> Vector46.Vector46 c -> Vector46.Vector46 d -> Vector46.Vector46 e -> Vector46.Vector46 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector46.Index -> (a -> a) -> Vector46.Vector46 a -> Vector46.Vector46 a"},{"name":"member","comment":" See if a Vector46 a contains a value ","type":"a -> Vector46.Vector46 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector46.Index -> Maybe.Maybe Vector46.Index"},{"name":"pop","comment":" Separate a `Vector46 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector46.Vector46 a -> ( Vector45.Internal.Vector45 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector46.Index -> Maybe.Maybe Vector46.Index"},{"name":"push","comment":" Add an element to the end of a `Vector46 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector46.Vector46 a -> Vector47.Internal.Vector47 a"},{"name":"repeat","comment":" Make a `Vector46 a` filled with just one item repeated over and over again. ","type":"a -> Vector46.Vector46 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector46 a` ","type":"Vector46.Vector46 a -> Vector46.Vector46 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector46 a` ","type":"Vector46.Index -> a -> Vector46.Vector46 a -> Vector46.Vector46 a"},{"name":"toIndexedList","comment":" Turn a `Vector46 a` elm into a list, where each element is paired with its `Index` ","type":"Vector46.Vector46 a -> List.List ( Vector46.Index, a )"},{"name":"toList","comment":" Convert a `Vector46 a` into a `List a` of length 46 ","type":"Vector46.Vector46 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector46 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector46.Vector46 a -> ( a, Vector45.Internal.Vector45 a )"}],"binops":[]},{"name":"Vector47","comment":" A vector of length 47\n\n# Vector47\n\n@docs Vector47\n\n# Creation\n\n@docs fromList, repeat, from47, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector47 a`. There are exactly 47 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]]]}],"aliases":[{"name":"Vector47","comment":" A vector that contains exactly 47 elements ","args":["a"],"type":"Vector47.Internal.Vector47 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector47.Vector47 a -> Vector48.Internal.Vector48 a"},{"name":"foldl","comment":" Reduce a `Vector47 a` from the left. ","type":"(a -> b -> b) -> b -> Vector47.Vector47 a -> b"},{"name":"foldr","comment":" Reduce a `Vector47 a` from the right. ","type":"(a -> b -> b) -> b -> Vector47.Vector47 a -> b"},{"name":"from47","comment":" Make a `Vector47 a` from 47 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector47.Vector47 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector47 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector47.Vector47 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector47 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector47.Vector47 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector47 a` ","type":"Vector47.Index -> Vector47.Vector47 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector47 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector47.Vector47 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector47.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector47.Index -> a -> b) -> Vector47.Vector47 a -> Vector47.Vector47 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 46 ","type":"Vector47.Vector47 Vector47.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector47 a` using a function that takes an `Index` ","type":"(Vector47.Index -> a) -> Vector47.Vector47 a"},{"name":"initializeFromInt","comment":" Make a `Vector47 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector47.Vector47 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector47 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector47.Index"},{"name":"length","comment":" The length of this vector type, which is 47 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector47 a`. ","type":"(a -> b) -> Vector47.Vector47 a -> Vector47.Vector47 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector47.Vector47 a -> Vector47.Vector47 b -> Vector47.Vector47 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector47.Vector47 a -> Vector47.Vector47 b -> Vector47.Vector47 c -> Vector47.Vector47 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector47.Vector47 a -> Vector47.Vector47 b -> Vector47.Vector47 c -> Vector47.Vector47 d -> Vector47.Vector47 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector47.Vector47 a -> Vector47.Vector47 b -> Vector47.Vector47 c -> Vector47.Vector47 d -> Vector47.Vector47 e -> Vector47.Vector47 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector47.Index -> (a -> a) -> Vector47.Vector47 a -> Vector47.Vector47 a"},{"name":"member","comment":" See if a Vector47 a contains a value ","type":"a -> Vector47.Vector47 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector47.Index -> Maybe.Maybe Vector47.Index"},{"name":"pop","comment":" Separate a `Vector47 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector47.Vector47 a -> ( Vector46.Internal.Vector46 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector47.Index -> Maybe.Maybe Vector47.Index"},{"name":"push","comment":" Add an element to the end of a `Vector47 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector47.Vector47 a -> Vector48.Internal.Vector48 a"},{"name":"repeat","comment":" Make a `Vector47 a` filled with just one item repeated over and over again. ","type":"a -> Vector47.Vector47 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector47 a` ","type":"Vector47.Vector47 a -> Vector47.Vector47 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector47 a` ","type":"Vector47.Index -> a -> Vector47.Vector47 a -> Vector47.Vector47 a"},{"name":"toIndexedList","comment":" Turn a `Vector47 a` elm into a list, where each element is paired with its `Index` ","type":"Vector47.Vector47 a -> List.List ( Vector47.Index, a )"},{"name":"toList","comment":" Convert a `Vector47 a` into a `List a` of length 47 ","type":"Vector47.Vector47 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector47 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector47.Vector47 a -> ( a, Vector46.Internal.Vector46 a )"}],"binops":[]},{"name":"Vector48","comment":" A vector of length 48\n\n# Vector48\n\n@docs Vector48\n\n# Creation\n\n@docs fromList, repeat, from48, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector48 a`. There are exactly 48 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]]]}],"aliases":[{"name":"Vector48","comment":" A vector that contains exactly 48 elements ","args":["a"],"type":"Vector48.Internal.Vector48 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector48.Vector48 a -> Vector49.Internal.Vector49 a"},{"name":"foldl","comment":" Reduce a `Vector48 a` from the left. ","type":"(a -> b -> b) -> b -> Vector48.Vector48 a -> b"},{"name":"foldr","comment":" Reduce a `Vector48 a` from the right. ","type":"(a -> b -> b) -> b -> Vector48.Vector48 a -> b"},{"name":"from48","comment":" Make a `Vector48 a` from 48 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector48.Vector48 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector48 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector48.Vector48 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector48 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector48.Vector48 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector48 a` ","type":"Vector48.Index -> Vector48.Vector48 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector48 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector48.Vector48 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector48.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector48.Index -> a -> b) -> Vector48.Vector48 a -> Vector48.Vector48 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 47 ","type":"Vector48.Vector48 Vector48.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector48 a` using a function that takes an `Index` ","type":"(Vector48.Index -> a) -> Vector48.Vector48 a"},{"name":"initializeFromInt","comment":" Make a `Vector48 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector48.Vector48 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector48 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector48.Index"},{"name":"length","comment":" The length of this vector type, which is 48 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector48 a`. ","type":"(a -> b) -> Vector48.Vector48 a -> Vector48.Vector48 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector48.Vector48 a -> Vector48.Vector48 b -> Vector48.Vector48 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector48.Vector48 a -> Vector48.Vector48 b -> Vector48.Vector48 c -> Vector48.Vector48 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector48.Vector48 a -> Vector48.Vector48 b -> Vector48.Vector48 c -> Vector48.Vector48 d -> Vector48.Vector48 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector48.Vector48 a -> Vector48.Vector48 b -> Vector48.Vector48 c -> Vector48.Vector48 d -> Vector48.Vector48 e -> Vector48.Vector48 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector48.Index -> (a -> a) -> Vector48.Vector48 a -> Vector48.Vector48 a"},{"name":"member","comment":" See if a Vector48 a contains a value ","type":"a -> Vector48.Vector48 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector48.Index -> Maybe.Maybe Vector48.Index"},{"name":"pop","comment":" Separate a `Vector48 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector48.Vector48 a -> ( Vector47.Internal.Vector47 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector48.Index -> Maybe.Maybe Vector48.Index"},{"name":"push","comment":" Add an element to the end of a `Vector48 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector48.Vector48 a -> Vector49.Internal.Vector49 a"},{"name":"repeat","comment":" Make a `Vector48 a` filled with just one item repeated over and over again. ","type":"a -> Vector48.Vector48 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector48 a` ","type":"Vector48.Vector48 a -> Vector48.Vector48 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector48 a` ","type":"Vector48.Index -> a -> Vector48.Vector48 a -> Vector48.Vector48 a"},{"name":"toIndexedList","comment":" Turn a `Vector48 a` elm into a list, where each element is paired with its `Index` ","type":"Vector48.Vector48 a -> List.List ( Vector48.Index, a )"},{"name":"toList","comment":" Convert a `Vector48 a` into a `List a` of length 48 ","type":"Vector48.Vector48 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector48 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector48.Vector48 a -> ( a, Vector47.Internal.Vector47 a )"}],"binops":[]},{"name":"Vector49","comment":" A vector of length 49\n\n# Vector49\n\n@docs Vector49\n\n# Creation\n\n@docs fromList, repeat, from49, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector49 a`. There are exactly 49 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]]]}],"aliases":[{"name":"Vector49","comment":" A vector that contains exactly 49 elements ","args":["a"],"type":"Vector49.Internal.Vector49 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector49.Vector49 a -> Vector50.Internal.Vector50 a"},{"name":"foldl","comment":" Reduce a `Vector49 a` from the left. ","type":"(a -> b -> b) -> b -> Vector49.Vector49 a -> b"},{"name":"foldr","comment":" Reduce a `Vector49 a` from the right. ","type":"(a -> b -> b) -> b -> Vector49.Vector49 a -> b"},{"name":"from49","comment":" Make a `Vector49 a` from 49 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector49.Vector49 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector49 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector49.Vector49 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector49 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector49.Vector49 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector49 a` ","type":"Vector49.Index -> Vector49.Vector49 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector49 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector49.Vector49 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector49.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector49.Index -> a -> b) -> Vector49.Vector49 a -> Vector49.Vector49 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 48 ","type":"Vector49.Vector49 Vector49.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector49 a` using a function that takes an `Index` ","type":"(Vector49.Index -> a) -> Vector49.Vector49 a"},{"name":"initializeFromInt","comment":" Make a `Vector49 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector49.Vector49 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector49 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector49.Index"},{"name":"length","comment":" The length of this vector type, which is 49 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector49 a`. ","type":"(a -> b) -> Vector49.Vector49 a -> Vector49.Vector49 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector49.Vector49 a -> Vector49.Vector49 b -> Vector49.Vector49 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector49.Vector49 a -> Vector49.Vector49 b -> Vector49.Vector49 c -> Vector49.Vector49 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector49.Vector49 a -> Vector49.Vector49 b -> Vector49.Vector49 c -> Vector49.Vector49 d -> Vector49.Vector49 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector49.Vector49 a -> Vector49.Vector49 b -> Vector49.Vector49 c -> Vector49.Vector49 d -> Vector49.Vector49 e -> Vector49.Vector49 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector49.Index -> (a -> a) -> Vector49.Vector49 a -> Vector49.Vector49 a"},{"name":"member","comment":" See if a Vector49 a contains a value ","type":"a -> Vector49.Vector49 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector49.Index -> Maybe.Maybe Vector49.Index"},{"name":"pop","comment":" Separate a `Vector49 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector49.Vector49 a -> ( Vector48.Internal.Vector48 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector49.Index -> Maybe.Maybe Vector49.Index"},{"name":"push","comment":" Add an element to the end of a `Vector49 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector49.Vector49 a -> Vector50.Internal.Vector50 a"},{"name":"repeat","comment":" Make a `Vector49 a` filled with just one item repeated over and over again. ","type":"a -> Vector49.Vector49 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector49 a` ","type":"Vector49.Vector49 a -> Vector49.Vector49 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector49 a` ","type":"Vector49.Index -> a -> Vector49.Vector49 a -> Vector49.Vector49 a"},{"name":"toIndexedList","comment":" Turn a `Vector49 a` elm into a list, where each element is paired with its `Index` ","type":"Vector49.Vector49 a -> List.List ( Vector49.Index, a )"},{"name":"toList","comment":" Convert a `Vector49 a` into a `List a` of length 49 ","type":"Vector49.Vector49 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector49 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector49.Vector49 a -> ( a, Vector48.Internal.Vector48 a )"}],"binops":[]},{"name":"Vector5","comment":" A vector of length 5\n\n# Vector5\n\n@docs Vector5\n\n# Creation\n\n@docs fromList, repeat, from5, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector5 a`. There are exactly 5 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]]]}],"aliases":[{"name":"Vector5","comment":" A vector that contains exactly 5 elements ","args":["a"],"type":"Vector5.Internal.Vector5 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector5.Vector5 a -> Vector6.Internal.Vector6 a"},{"name":"foldl","comment":" Reduce a `Vector5 a` from the left. ","type":"(a -> b -> b) -> b -> Vector5.Vector5 a -> b"},{"name":"foldr","comment":" Reduce a `Vector5 a` from the right. ","type":"(a -> b -> b) -> b -> Vector5.Vector5 a -> b"},{"name":"from5","comment":" Make a `Vector5 a` from 5 elements ","type":"a -> a -> a -> a -> a -> Vector5.Vector5 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector5 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector5.Vector5 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector5 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector5.Vector5 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector5 a` ","type":"Vector5.Index -> Vector5.Vector5 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector5 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector5.Vector5 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector5.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector5.Index -> a -> b) -> Vector5.Vector5 a -> Vector5.Vector5 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 4 ","type":"Vector5.Vector5 Vector5.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector5 a` using a function that takes an `Index` ","type":"(Vector5.Index -> a) -> Vector5.Vector5 a"},{"name":"initializeFromInt","comment":" Make a `Vector5 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector5.Vector5 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector5 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector5.Index"},{"name":"length","comment":" The length of this vector type, which is 5 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector5 a`. ","type":"(a -> b) -> Vector5.Vector5 a -> Vector5.Vector5 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector5.Vector5 a -> Vector5.Vector5 b -> Vector5.Vector5 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector5.Vector5 a -> Vector5.Vector5 b -> Vector5.Vector5 c -> Vector5.Vector5 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector5.Vector5 a -> Vector5.Vector5 b -> Vector5.Vector5 c -> Vector5.Vector5 d -> Vector5.Vector5 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector5.Vector5 a -> Vector5.Vector5 b -> Vector5.Vector5 c -> Vector5.Vector5 d -> Vector5.Vector5 e -> Vector5.Vector5 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector5.Index -> (a -> a) -> Vector5.Vector5 a -> Vector5.Vector5 a"},{"name":"member","comment":" See if a Vector5 a contains a value ","type":"a -> Vector5.Vector5 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector5.Index -> Maybe.Maybe Vector5.Index"},{"name":"pop","comment":" Separate a `Vector5 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector5.Vector5 a -> ( Vector4.Internal.Vector4 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector5.Index -> Maybe.Maybe Vector5.Index"},{"name":"push","comment":" Add an element to the end of a `Vector5 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector5.Vector5 a -> Vector6.Internal.Vector6 a"},{"name":"repeat","comment":" Make a `Vector5 a` filled with just one item repeated over and over again. ","type":"a -> Vector5.Vector5 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector5 a` ","type":"Vector5.Vector5 a -> Vector5.Vector5 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector5 a` ","type":"Vector5.Index -> a -> Vector5.Vector5 a -> Vector5.Vector5 a"},{"name":"toIndexedList","comment":" Turn a `Vector5 a` elm into a list, where each element is paired with its `Index` ","type":"Vector5.Vector5 a -> List.List ( Vector5.Index, a )"},{"name":"toList","comment":" Convert a `Vector5 a` into a `List a` of length 5 ","type":"Vector5.Vector5 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector5 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector5.Vector5 a -> ( a, Vector4.Internal.Vector4 a )"}],"binops":[]},{"name":"Vector50","comment":" A vector of length 50\n\n# Vector50\n\n@docs Vector50\n\n# Creation\n\n@docs fromList, repeat, from50, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector50 a`. There are exactly 50 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]]]}],"aliases":[{"name":"Vector50","comment":" A vector that contains exactly 50 elements ","args":["a"],"type":"Vector50.Internal.Vector50 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector50.Vector50 a -> Vector51.Internal.Vector51 a"},{"name":"foldl","comment":" Reduce a `Vector50 a` from the left. ","type":"(a -> b -> b) -> b -> Vector50.Vector50 a -> b"},{"name":"foldr","comment":" Reduce a `Vector50 a` from the right. ","type":"(a -> b -> b) -> b -> Vector50.Vector50 a -> b"},{"name":"from50","comment":" Make a `Vector50 a` from 50 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector50.Vector50 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector50 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector50.Vector50 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector50 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector50.Vector50 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector50 a` ","type":"Vector50.Index -> Vector50.Vector50 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector50 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector50.Vector50 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector50.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector50.Index -> a -> b) -> Vector50.Vector50 a -> Vector50.Vector50 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 49 ","type":"Vector50.Vector50 Vector50.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector50 a` using a function that takes an `Index` ","type":"(Vector50.Index -> a) -> Vector50.Vector50 a"},{"name":"initializeFromInt","comment":" Make a `Vector50 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector50.Vector50 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector50 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector50.Index"},{"name":"length","comment":" The length of this vector type, which is 50 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector50 a`. ","type":"(a -> b) -> Vector50.Vector50 a -> Vector50.Vector50 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector50.Vector50 a -> Vector50.Vector50 b -> Vector50.Vector50 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector50.Vector50 a -> Vector50.Vector50 b -> Vector50.Vector50 c -> Vector50.Vector50 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector50.Vector50 a -> Vector50.Vector50 b -> Vector50.Vector50 c -> Vector50.Vector50 d -> Vector50.Vector50 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector50.Vector50 a -> Vector50.Vector50 b -> Vector50.Vector50 c -> Vector50.Vector50 d -> Vector50.Vector50 e -> Vector50.Vector50 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector50.Index -> (a -> a) -> Vector50.Vector50 a -> Vector50.Vector50 a"},{"name":"member","comment":" See if a Vector50 a contains a value ","type":"a -> Vector50.Vector50 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector50.Index -> Maybe.Maybe Vector50.Index"},{"name":"pop","comment":" Separate a `Vector50 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector50.Vector50 a -> ( Vector49.Internal.Vector49 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector50.Index -> Maybe.Maybe Vector50.Index"},{"name":"push","comment":" Add an element to the end of a `Vector50 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector50.Vector50 a -> Vector51.Internal.Vector51 a"},{"name":"repeat","comment":" Make a `Vector50 a` filled with just one item repeated over and over again. ","type":"a -> Vector50.Vector50 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector50 a` ","type":"Vector50.Vector50 a -> Vector50.Vector50 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector50 a` ","type":"Vector50.Index -> a -> Vector50.Vector50 a -> Vector50.Vector50 a"},{"name":"toIndexedList","comment":" Turn a `Vector50 a` elm into a list, where each element is paired with its `Index` ","type":"Vector50.Vector50 a -> List.List ( Vector50.Index, a )"},{"name":"toList","comment":" Convert a `Vector50 a` into a `List a` of length 50 ","type":"Vector50.Vector50 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector50 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector50.Vector50 a -> ( a, Vector49.Internal.Vector49 a )"}],"binops":[]},{"name":"Vector51","comment":" A vector of length 51\n\n# Vector51\n\n@docs Vector51\n\n# Creation\n\n@docs fromList, repeat, from51, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector51 a`. There are exactly 51 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]]]}],"aliases":[{"name":"Vector51","comment":" A vector that contains exactly 51 elements ","args":["a"],"type":"Vector51.Internal.Vector51 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector51.Vector51 a -> Vector52.Internal.Vector52 a"},{"name":"foldl","comment":" Reduce a `Vector51 a` from the left. ","type":"(a -> b -> b) -> b -> Vector51.Vector51 a -> b"},{"name":"foldr","comment":" Reduce a `Vector51 a` from the right. ","type":"(a -> b -> b) -> b -> Vector51.Vector51 a -> b"},{"name":"from51","comment":" Make a `Vector51 a` from 51 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector51.Vector51 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector51 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector51.Vector51 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector51 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector51.Vector51 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector51 a` ","type":"Vector51.Index -> Vector51.Vector51 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector51 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector51.Vector51 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector51.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector51.Index -> a -> b) -> Vector51.Vector51 a -> Vector51.Vector51 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 50 ","type":"Vector51.Vector51 Vector51.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector51 a` using a function that takes an `Index` ","type":"(Vector51.Index -> a) -> Vector51.Vector51 a"},{"name":"initializeFromInt","comment":" Make a `Vector51 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector51.Vector51 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector51 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector51.Index"},{"name":"length","comment":" The length of this vector type, which is 51 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector51 a`. ","type":"(a -> b) -> Vector51.Vector51 a -> Vector51.Vector51 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector51.Vector51 a -> Vector51.Vector51 b -> Vector51.Vector51 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector51.Vector51 a -> Vector51.Vector51 b -> Vector51.Vector51 c -> Vector51.Vector51 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector51.Vector51 a -> Vector51.Vector51 b -> Vector51.Vector51 c -> Vector51.Vector51 d -> Vector51.Vector51 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector51.Vector51 a -> Vector51.Vector51 b -> Vector51.Vector51 c -> Vector51.Vector51 d -> Vector51.Vector51 e -> Vector51.Vector51 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector51.Index -> (a -> a) -> Vector51.Vector51 a -> Vector51.Vector51 a"},{"name":"member","comment":" See if a Vector51 a contains a value ","type":"a -> Vector51.Vector51 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector51.Index -> Maybe.Maybe Vector51.Index"},{"name":"pop","comment":" Separate a `Vector51 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector51.Vector51 a -> ( Vector50.Internal.Vector50 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector51.Index -> Maybe.Maybe Vector51.Index"},{"name":"push","comment":" Add an element to the end of a `Vector51 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector51.Vector51 a -> Vector52.Internal.Vector52 a"},{"name":"repeat","comment":" Make a `Vector51 a` filled with just one item repeated over and over again. ","type":"a -> Vector51.Vector51 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector51 a` ","type":"Vector51.Vector51 a -> Vector51.Vector51 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector51 a` ","type":"Vector51.Index -> a -> Vector51.Vector51 a -> Vector51.Vector51 a"},{"name":"toIndexedList","comment":" Turn a `Vector51 a` elm into a list, where each element is paired with its `Index` ","type":"Vector51.Vector51 a -> List.List ( Vector51.Index, a )"},{"name":"toList","comment":" Convert a `Vector51 a` into a `List a` of length 51 ","type":"Vector51.Vector51 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector51 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector51.Vector51 a -> ( a, Vector50.Internal.Vector50 a )"}],"binops":[]},{"name":"Vector52","comment":" A vector of length 52\n\n# Vector52\n\n@docs Vector52\n\n# Creation\n\n@docs fromList, repeat, from52, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector52 a`. There are exactly 52 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]],["Index51",[]]]}],"aliases":[{"name":"Vector52","comment":" A vector that contains exactly 52 elements ","args":["a"],"type":"Vector52.Internal.Vector52 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector52.Vector52 a -> Vector53.Internal.Vector53 a"},{"name":"foldl","comment":" Reduce a `Vector52 a` from the left. ","type":"(a -> b -> b) -> b -> Vector52.Vector52 a -> b"},{"name":"foldr","comment":" Reduce a `Vector52 a` from the right. ","type":"(a -> b -> b) -> b -> Vector52.Vector52 a -> b"},{"name":"from52","comment":" Make a `Vector52 a` from 52 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector52.Vector52 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector52 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector52.Vector52 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector52 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector52.Vector52 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector52 a` ","type":"Vector52.Index -> Vector52.Vector52 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector52 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector52.Vector52 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector52.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector52.Index -> a -> b) -> Vector52.Vector52 a -> Vector52.Vector52 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 51 ","type":"Vector52.Vector52 Vector52.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector52 a` using a function that takes an `Index` ","type":"(Vector52.Index -> a) -> Vector52.Vector52 a"},{"name":"initializeFromInt","comment":" Make a `Vector52 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector52.Vector52 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector52 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector52.Index"},{"name":"length","comment":" The length of this vector type, which is 52 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector52 a`. ","type":"(a -> b) -> Vector52.Vector52 a -> Vector52.Vector52 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector52.Vector52 a -> Vector52.Vector52 b -> Vector52.Vector52 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector52.Vector52 a -> Vector52.Vector52 b -> Vector52.Vector52 c -> Vector52.Vector52 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector52.Vector52 a -> Vector52.Vector52 b -> Vector52.Vector52 c -> Vector52.Vector52 d -> Vector52.Vector52 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector52.Vector52 a -> Vector52.Vector52 b -> Vector52.Vector52 c -> Vector52.Vector52 d -> Vector52.Vector52 e -> Vector52.Vector52 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector52.Index -> (a -> a) -> Vector52.Vector52 a -> Vector52.Vector52 a"},{"name":"member","comment":" See if a Vector52 a contains a value ","type":"a -> Vector52.Vector52 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector52.Index -> Maybe.Maybe Vector52.Index"},{"name":"pop","comment":" Separate a `Vector52 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector52.Vector52 a -> ( Vector51.Internal.Vector51 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector52.Index -> Maybe.Maybe Vector52.Index"},{"name":"push","comment":" Add an element to the end of a `Vector52 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector52.Vector52 a -> Vector53.Internal.Vector53 a"},{"name":"repeat","comment":" Make a `Vector52 a` filled with just one item repeated over and over again. ","type":"a -> Vector52.Vector52 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector52 a` ","type":"Vector52.Vector52 a -> Vector52.Vector52 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector52 a` ","type":"Vector52.Index -> a -> Vector52.Vector52 a -> Vector52.Vector52 a"},{"name":"toIndexedList","comment":" Turn a `Vector52 a` elm into a list, where each element is paired with its `Index` ","type":"Vector52.Vector52 a -> List.List ( Vector52.Index, a )"},{"name":"toList","comment":" Convert a `Vector52 a` into a `List a` of length 52 ","type":"Vector52.Vector52 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector52 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector52.Vector52 a -> ( a, Vector51.Internal.Vector51 a )"}],"binops":[]},{"name":"Vector53","comment":" A vector of length 53\n\n# Vector53\n\n@docs Vector53\n\n# Creation\n\n@docs fromList, repeat, from53, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector53 a`. There are exactly 53 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]],["Index51",[]],["Index52",[]]]}],"aliases":[{"name":"Vector53","comment":" A vector that contains exactly 53 elements ","args":["a"],"type":"Vector53.Internal.Vector53 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector53.Vector53 a -> Vector54.Internal.Vector54 a"},{"name":"foldl","comment":" Reduce a `Vector53 a` from the left. ","type":"(a -> b -> b) -> b -> Vector53.Vector53 a -> b"},{"name":"foldr","comment":" Reduce a `Vector53 a` from the right. ","type":"(a -> b -> b) -> b -> Vector53.Vector53 a -> b"},{"name":"from53","comment":" Make a `Vector53 a` from 53 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector53.Vector53 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector53 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector53.Vector53 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector53 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector53.Vector53 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector53 a` ","type":"Vector53.Index -> Vector53.Vector53 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector53 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector53.Vector53 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector53.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector53.Index -> a -> b) -> Vector53.Vector53 a -> Vector53.Vector53 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 52 ","type":"Vector53.Vector53 Vector53.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector53 a` using a function that takes an `Index` ","type":"(Vector53.Index -> a) -> Vector53.Vector53 a"},{"name":"initializeFromInt","comment":" Make a `Vector53 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector53.Vector53 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector53 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector53.Index"},{"name":"length","comment":" The length of this vector type, which is 53 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector53 a`. ","type":"(a -> b) -> Vector53.Vector53 a -> Vector53.Vector53 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector53.Vector53 a -> Vector53.Vector53 b -> Vector53.Vector53 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector53.Vector53 a -> Vector53.Vector53 b -> Vector53.Vector53 c -> Vector53.Vector53 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector53.Vector53 a -> Vector53.Vector53 b -> Vector53.Vector53 c -> Vector53.Vector53 d -> Vector53.Vector53 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector53.Vector53 a -> Vector53.Vector53 b -> Vector53.Vector53 c -> Vector53.Vector53 d -> Vector53.Vector53 e -> Vector53.Vector53 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector53.Index -> (a -> a) -> Vector53.Vector53 a -> Vector53.Vector53 a"},{"name":"member","comment":" See if a Vector53 a contains a value ","type":"a -> Vector53.Vector53 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector53.Index -> Maybe.Maybe Vector53.Index"},{"name":"pop","comment":" Separate a `Vector53 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector53.Vector53 a -> ( Vector52.Internal.Vector52 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector53.Index -> Maybe.Maybe Vector53.Index"},{"name":"push","comment":" Add an element to the end of a `Vector53 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector53.Vector53 a -> Vector54.Internal.Vector54 a"},{"name":"repeat","comment":" Make a `Vector53 a` filled with just one item repeated over and over again. ","type":"a -> Vector53.Vector53 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector53 a` ","type":"Vector53.Vector53 a -> Vector53.Vector53 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector53 a` ","type":"Vector53.Index -> a -> Vector53.Vector53 a -> Vector53.Vector53 a"},{"name":"toIndexedList","comment":" Turn a `Vector53 a` elm into a list, where each element is paired with its `Index` ","type":"Vector53.Vector53 a -> List.List ( Vector53.Index, a )"},{"name":"toList","comment":" Convert a `Vector53 a` into a `List a` of length 53 ","type":"Vector53.Vector53 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector53 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector53.Vector53 a -> ( a, Vector52.Internal.Vector52 a )"}],"binops":[]},{"name":"Vector54","comment":" A vector of length 54\n\n# Vector54\n\n@docs Vector54\n\n# Creation\n\n@docs fromList, repeat, from54, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector54 a`. There are exactly 54 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]],["Index51",[]],["Index52",[]],["Index53",[]]]}],"aliases":[{"name":"Vector54","comment":" A vector that contains exactly 54 elements ","args":["a"],"type":"Vector54.Internal.Vector54 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector54.Vector54 a -> Vector55.Internal.Vector55 a"},{"name":"foldl","comment":" Reduce a `Vector54 a` from the left. ","type":"(a -> b -> b) -> b -> Vector54.Vector54 a -> b"},{"name":"foldr","comment":" Reduce a `Vector54 a` from the right. ","type":"(a -> b -> b) -> b -> Vector54.Vector54 a -> b"},{"name":"from54","comment":" Make a `Vector54 a` from 54 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector54.Vector54 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector54 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector54.Vector54 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector54 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector54.Vector54 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector54 a` ","type":"Vector54.Index -> Vector54.Vector54 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector54 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector54.Vector54 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector54.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector54.Index -> a -> b) -> Vector54.Vector54 a -> Vector54.Vector54 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 53 ","type":"Vector54.Vector54 Vector54.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector54 a` using a function that takes an `Index` ","type":"(Vector54.Index -> a) -> Vector54.Vector54 a"},{"name":"initializeFromInt","comment":" Make a `Vector54 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector54.Vector54 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector54 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector54.Index"},{"name":"length","comment":" The length of this vector type, which is 54 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector54 a`. ","type":"(a -> b) -> Vector54.Vector54 a -> Vector54.Vector54 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector54.Vector54 a -> Vector54.Vector54 b -> Vector54.Vector54 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector54.Vector54 a -> Vector54.Vector54 b -> Vector54.Vector54 c -> Vector54.Vector54 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector54.Vector54 a -> Vector54.Vector54 b -> Vector54.Vector54 c -> Vector54.Vector54 d -> Vector54.Vector54 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector54.Vector54 a -> Vector54.Vector54 b -> Vector54.Vector54 c -> Vector54.Vector54 d -> Vector54.Vector54 e -> Vector54.Vector54 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector54.Index -> (a -> a) -> Vector54.Vector54 a -> Vector54.Vector54 a"},{"name":"member","comment":" See if a Vector54 a contains a value ","type":"a -> Vector54.Vector54 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector54.Index -> Maybe.Maybe Vector54.Index"},{"name":"pop","comment":" Separate a `Vector54 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector54.Vector54 a -> ( Vector53.Internal.Vector53 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector54.Index -> Maybe.Maybe Vector54.Index"},{"name":"push","comment":" Add an element to the end of a `Vector54 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector54.Vector54 a -> Vector55.Internal.Vector55 a"},{"name":"repeat","comment":" Make a `Vector54 a` filled with just one item repeated over and over again. ","type":"a -> Vector54.Vector54 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector54 a` ","type":"Vector54.Vector54 a -> Vector54.Vector54 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector54 a` ","type":"Vector54.Index -> a -> Vector54.Vector54 a -> Vector54.Vector54 a"},{"name":"toIndexedList","comment":" Turn a `Vector54 a` elm into a list, where each element is paired with its `Index` ","type":"Vector54.Vector54 a -> List.List ( Vector54.Index, a )"},{"name":"toList","comment":" Convert a `Vector54 a` into a `List a` of length 54 ","type":"Vector54.Vector54 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector54 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector54.Vector54 a -> ( a, Vector53.Internal.Vector53 a )"}],"binops":[]},{"name":"Vector55","comment":" A vector of length 55\n\n# Vector55\n\n@docs Vector55\n\n# Creation\n\n@docs fromList, repeat, from55, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector55 a`. There are exactly 55 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]],["Index51",[]],["Index52",[]],["Index53",[]],["Index54",[]]]}],"aliases":[{"name":"Vector55","comment":" A vector that contains exactly 55 elements ","args":["a"],"type":"Vector55.Internal.Vector55 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector55.Vector55 a -> Vector56.Internal.Vector56 a"},{"name":"foldl","comment":" Reduce a `Vector55 a` from the left. ","type":"(a -> b -> b) -> b -> Vector55.Vector55 a -> b"},{"name":"foldr","comment":" Reduce a `Vector55 a` from the right. ","type":"(a -> b -> b) -> b -> Vector55.Vector55 a -> b"},{"name":"from55","comment":" Make a `Vector55 a` from 55 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector55.Vector55 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector55 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector55.Vector55 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector55 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector55.Vector55 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector55 a` ","type":"Vector55.Index -> Vector55.Vector55 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector55 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector55.Vector55 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector55.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector55.Index -> a -> b) -> Vector55.Vector55 a -> Vector55.Vector55 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 54 ","type":"Vector55.Vector55 Vector55.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector55 a` using a function that takes an `Index` ","type":"(Vector55.Index -> a) -> Vector55.Vector55 a"},{"name":"initializeFromInt","comment":" Make a `Vector55 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector55.Vector55 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector55 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector55.Index"},{"name":"length","comment":" The length of this vector type, which is 55 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector55 a`. ","type":"(a -> b) -> Vector55.Vector55 a -> Vector55.Vector55 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector55.Vector55 a -> Vector55.Vector55 b -> Vector55.Vector55 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector55.Vector55 a -> Vector55.Vector55 b -> Vector55.Vector55 c -> Vector55.Vector55 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector55.Vector55 a -> Vector55.Vector55 b -> Vector55.Vector55 c -> Vector55.Vector55 d -> Vector55.Vector55 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector55.Vector55 a -> Vector55.Vector55 b -> Vector55.Vector55 c -> Vector55.Vector55 d -> Vector55.Vector55 e -> Vector55.Vector55 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector55.Index -> (a -> a) -> Vector55.Vector55 a -> Vector55.Vector55 a"},{"name":"member","comment":" See if a Vector55 a contains a value ","type":"a -> Vector55.Vector55 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector55.Index -> Maybe.Maybe Vector55.Index"},{"name":"pop","comment":" Separate a `Vector55 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector55.Vector55 a -> ( Vector54.Internal.Vector54 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector55.Index -> Maybe.Maybe Vector55.Index"},{"name":"push","comment":" Add an element to the end of a `Vector55 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector55.Vector55 a -> Vector56.Internal.Vector56 a"},{"name":"repeat","comment":" Make a `Vector55 a` filled with just one item repeated over and over again. ","type":"a -> Vector55.Vector55 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector55 a` ","type":"Vector55.Vector55 a -> Vector55.Vector55 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector55 a` ","type":"Vector55.Index -> a -> Vector55.Vector55 a -> Vector55.Vector55 a"},{"name":"toIndexedList","comment":" Turn a `Vector55 a` elm into a list, where each element is paired with its `Index` ","type":"Vector55.Vector55 a -> List.List ( Vector55.Index, a )"},{"name":"toList","comment":" Convert a `Vector55 a` into a `List a` of length 55 ","type":"Vector55.Vector55 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector55 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector55.Vector55 a -> ( a, Vector54.Internal.Vector54 a )"}],"binops":[]},{"name":"Vector56","comment":" A vector of length 56\n\n# Vector56\n\n@docs Vector56\n\n# Creation\n\n@docs fromList, repeat, from56, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector56 a`. There are exactly 56 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]],["Index51",[]],["Index52",[]],["Index53",[]],["Index54",[]],["Index55",[]]]}],"aliases":[{"name":"Vector56","comment":" A vector that contains exactly 56 elements ","args":["a"],"type":"Vector56.Internal.Vector56 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector56.Vector56 a -> Vector57.Internal.Vector57 a"},{"name":"foldl","comment":" Reduce a `Vector56 a` from the left. ","type":"(a -> b -> b) -> b -> Vector56.Vector56 a -> b"},{"name":"foldr","comment":" Reduce a `Vector56 a` from the right. ","type":"(a -> b -> b) -> b -> Vector56.Vector56 a -> b"},{"name":"from56","comment":" Make a `Vector56 a` from 56 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector56.Vector56 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector56 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector56.Vector56 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector56 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector56.Vector56 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector56 a` ","type":"Vector56.Index -> Vector56.Vector56 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector56 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector56.Vector56 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector56.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector56.Index -> a -> b) -> Vector56.Vector56 a -> Vector56.Vector56 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 55 ","type":"Vector56.Vector56 Vector56.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector56 a` using a function that takes an `Index` ","type":"(Vector56.Index -> a) -> Vector56.Vector56 a"},{"name":"initializeFromInt","comment":" Make a `Vector56 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector56.Vector56 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector56 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector56.Index"},{"name":"length","comment":" The length of this vector type, which is 56 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector56 a`. ","type":"(a -> b) -> Vector56.Vector56 a -> Vector56.Vector56 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector56.Vector56 a -> Vector56.Vector56 b -> Vector56.Vector56 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector56.Vector56 a -> Vector56.Vector56 b -> Vector56.Vector56 c -> Vector56.Vector56 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector56.Vector56 a -> Vector56.Vector56 b -> Vector56.Vector56 c -> Vector56.Vector56 d -> Vector56.Vector56 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector56.Vector56 a -> Vector56.Vector56 b -> Vector56.Vector56 c -> Vector56.Vector56 d -> Vector56.Vector56 e -> Vector56.Vector56 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector56.Index -> (a -> a) -> Vector56.Vector56 a -> Vector56.Vector56 a"},{"name":"member","comment":" See if a Vector56 a contains a value ","type":"a -> Vector56.Vector56 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector56.Index -> Maybe.Maybe Vector56.Index"},{"name":"pop","comment":" Separate a `Vector56 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector56.Vector56 a -> ( Vector55.Internal.Vector55 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector56.Index -> Maybe.Maybe Vector56.Index"},{"name":"push","comment":" Add an element to the end of a `Vector56 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector56.Vector56 a -> Vector57.Internal.Vector57 a"},{"name":"repeat","comment":" Make a `Vector56 a` filled with just one item repeated over and over again. ","type":"a -> Vector56.Vector56 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector56 a` ","type":"Vector56.Vector56 a -> Vector56.Vector56 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector56 a` ","type":"Vector56.Index -> a -> Vector56.Vector56 a -> Vector56.Vector56 a"},{"name":"toIndexedList","comment":" Turn a `Vector56 a` elm into a list, where each element is paired with its `Index` ","type":"Vector56.Vector56 a -> List.List ( Vector56.Index, a )"},{"name":"toList","comment":" Convert a `Vector56 a` into a `List a` of length 56 ","type":"Vector56.Vector56 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector56 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector56.Vector56 a -> ( a, Vector55.Internal.Vector55 a )"}],"binops":[]},{"name":"Vector57","comment":" A vector of length 57\n\n# Vector57\n\n@docs Vector57\n\n# Creation\n\n@docs fromList, repeat, from57, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector57 a`. There are exactly 57 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]],["Index51",[]],["Index52",[]],["Index53",[]],["Index54",[]],["Index55",[]],["Index56",[]]]}],"aliases":[{"name":"Vector57","comment":" A vector that contains exactly 57 elements ","args":["a"],"type":"Vector57.Internal.Vector57 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector57.Vector57 a -> Vector58.Internal.Vector58 a"},{"name":"foldl","comment":" Reduce a `Vector57 a` from the left. ","type":"(a -> b -> b) -> b -> Vector57.Vector57 a -> b"},{"name":"foldr","comment":" Reduce a `Vector57 a` from the right. ","type":"(a -> b -> b) -> b -> Vector57.Vector57 a -> b"},{"name":"from57","comment":" Make a `Vector57 a` from 57 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector57.Vector57 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector57 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector57.Vector57 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector57 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector57.Vector57 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector57 a` ","type":"Vector57.Index -> Vector57.Vector57 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector57 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector57.Vector57 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector57.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector57.Index -> a -> b) -> Vector57.Vector57 a -> Vector57.Vector57 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 56 ","type":"Vector57.Vector57 Vector57.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector57 a` using a function that takes an `Index` ","type":"(Vector57.Index -> a) -> Vector57.Vector57 a"},{"name":"initializeFromInt","comment":" Make a `Vector57 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector57.Vector57 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector57 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector57.Index"},{"name":"length","comment":" The length of this vector type, which is 57 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector57 a`. ","type":"(a -> b) -> Vector57.Vector57 a -> Vector57.Vector57 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector57.Vector57 a -> Vector57.Vector57 b -> Vector57.Vector57 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector57.Vector57 a -> Vector57.Vector57 b -> Vector57.Vector57 c -> Vector57.Vector57 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector57.Vector57 a -> Vector57.Vector57 b -> Vector57.Vector57 c -> Vector57.Vector57 d -> Vector57.Vector57 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector57.Vector57 a -> Vector57.Vector57 b -> Vector57.Vector57 c -> Vector57.Vector57 d -> Vector57.Vector57 e -> Vector57.Vector57 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector57.Index -> (a -> a) -> Vector57.Vector57 a -> Vector57.Vector57 a"},{"name":"member","comment":" See if a Vector57 a contains a value ","type":"a -> Vector57.Vector57 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector57.Index -> Maybe.Maybe Vector57.Index"},{"name":"pop","comment":" Separate a `Vector57 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector57.Vector57 a -> ( Vector56.Internal.Vector56 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector57.Index -> Maybe.Maybe Vector57.Index"},{"name":"push","comment":" Add an element to the end of a `Vector57 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector57.Vector57 a -> Vector58.Internal.Vector58 a"},{"name":"repeat","comment":" Make a `Vector57 a` filled with just one item repeated over and over again. ","type":"a -> Vector57.Vector57 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector57 a` ","type":"Vector57.Vector57 a -> Vector57.Vector57 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector57 a` ","type":"Vector57.Index -> a -> Vector57.Vector57 a -> Vector57.Vector57 a"},{"name":"toIndexedList","comment":" Turn a `Vector57 a` elm into a list, where each element is paired with its `Index` ","type":"Vector57.Vector57 a -> List.List ( Vector57.Index, a )"},{"name":"toList","comment":" Convert a `Vector57 a` into a `List a` of length 57 ","type":"Vector57.Vector57 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector57 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector57.Vector57 a -> ( a, Vector56.Internal.Vector56 a )"}],"binops":[]},{"name":"Vector58","comment":" A vector of length 58\n\n# Vector58\n\n@docs Vector58\n\n# Creation\n\n@docs fromList, repeat, from58, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector58 a`. There are exactly 58 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]],["Index51",[]],["Index52",[]],["Index53",[]],["Index54",[]],["Index55",[]],["Index56",[]],["Index57",[]]]}],"aliases":[{"name":"Vector58","comment":" A vector that contains exactly 58 elements ","args":["a"],"type":"Vector58.Internal.Vector58 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector58.Vector58 a -> Vector59.Internal.Vector59 a"},{"name":"foldl","comment":" Reduce a `Vector58 a` from the left. ","type":"(a -> b -> b) -> b -> Vector58.Vector58 a -> b"},{"name":"foldr","comment":" Reduce a `Vector58 a` from the right. ","type":"(a -> b -> b) -> b -> Vector58.Vector58 a -> b"},{"name":"from58","comment":" Make a `Vector58 a` from 58 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector58.Vector58 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector58 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector58.Vector58 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector58 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector58.Vector58 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector58 a` ","type":"Vector58.Index -> Vector58.Vector58 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector58 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector58.Vector58 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector58.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector58.Index -> a -> b) -> Vector58.Vector58 a -> Vector58.Vector58 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 57 ","type":"Vector58.Vector58 Vector58.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector58 a` using a function that takes an `Index` ","type":"(Vector58.Index -> a) -> Vector58.Vector58 a"},{"name":"initializeFromInt","comment":" Make a `Vector58 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector58.Vector58 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector58 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector58.Index"},{"name":"length","comment":" The length of this vector type, which is 58 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector58 a`. ","type":"(a -> b) -> Vector58.Vector58 a -> Vector58.Vector58 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector58.Vector58 a -> Vector58.Vector58 b -> Vector58.Vector58 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector58.Vector58 a -> Vector58.Vector58 b -> Vector58.Vector58 c -> Vector58.Vector58 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector58.Vector58 a -> Vector58.Vector58 b -> Vector58.Vector58 c -> Vector58.Vector58 d -> Vector58.Vector58 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector58.Vector58 a -> Vector58.Vector58 b -> Vector58.Vector58 c -> Vector58.Vector58 d -> Vector58.Vector58 e -> Vector58.Vector58 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector58.Index -> (a -> a) -> Vector58.Vector58 a -> Vector58.Vector58 a"},{"name":"member","comment":" See if a Vector58 a contains a value ","type":"a -> Vector58.Vector58 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector58.Index -> Maybe.Maybe Vector58.Index"},{"name":"pop","comment":" Separate a `Vector58 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector58.Vector58 a -> ( Vector57.Internal.Vector57 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector58.Index -> Maybe.Maybe Vector58.Index"},{"name":"push","comment":" Add an element to the end of a `Vector58 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector58.Vector58 a -> Vector59.Internal.Vector59 a"},{"name":"repeat","comment":" Make a `Vector58 a` filled with just one item repeated over and over again. ","type":"a -> Vector58.Vector58 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector58 a` ","type":"Vector58.Vector58 a -> Vector58.Vector58 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector58 a` ","type":"Vector58.Index -> a -> Vector58.Vector58 a -> Vector58.Vector58 a"},{"name":"toIndexedList","comment":" Turn a `Vector58 a` elm into a list, where each element is paired with its `Index` ","type":"Vector58.Vector58 a -> List.List ( Vector58.Index, a )"},{"name":"toList","comment":" Convert a `Vector58 a` into a `List a` of length 58 ","type":"Vector58.Vector58 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector58 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector58.Vector58 a -> ( a, Vector57.Internal.Vector57 a )"}],"binops":[]},{"name":"Vector59","comment":" A vector of length 59\n\n# Vector59\n\n@docs Vector59\n\n# Creation\n\n@docs fromList, repeat, from59, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector59 a`. There are exactly 59 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]],["Index51",[]],["Index52",[]],["Index53",[]],["Index54",[]],["Index55",[]],["Index56",[]],["Index57",[]],["Index58",[]]]}],"aliases":[{"name":"Vector59","comment":" A vector that contains exactly 59 elements ","args":["a"],"type":"Vector59.Internal.Vector59 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector59.Vector59 a -> Vector60.Internal.Vector60 a"},{"name":"foldl","comment":" Reduce a `Vector59 a` from the left. ","type":"(a -> b -> b) -> b -> Vector59.Vector59 a -> b"},{"name":"foldr","comment":" Reduce a `Vector59 a` from the right. ","type":"(a -> b -> b) -> b -> Vector59.Vector59 a -> b"},{"name":"from59","comment":" Make a `Vector59 a` from 59 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector59.Vector59 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector59 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector59.Vector59 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector59 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector59.Vector59 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector59 a` ","type":"Vector59.Index -> Vector59.Vector59 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector59 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector59.Vector59 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector59.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector59.Index -> a -> b) -> Vector59.Vector59 a -> Vector59.Vector59 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 58 ","type":"Vector59.Vector59 Vector59.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector59 a` using a function that takes an `Index` ","type":"(Vector59.Index -> a) -> Vector59.Vector59 a"},{"name":"initializeFromInt","comment":" Make a `Vector59 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector59.Vector59 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector59 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector59.Index"},{"name":"length","comment":" The length of this vector type, which is 59 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector59 a`. ","type":"(a -> b) -> Vector59.Vector59 a -> Vector59.Vector59 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector59.Vector59 a -> Vector59.Vector59 b -> Vector59.Vector59 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector59.Vector59 a -> Vector59.Vector59 b -> Vector59.Vector59 c -> Vector59.Vector59 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector59.Vector59 a -> Vector59.Vector59 b -> Vector59.Vector59 c -> Vector59.Vector59 d -> Vector59.Vector59 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector59.Vector59 a -> Vector59.Vector59 b -> Vector59.Vector59 c -> Vector59.Vector59 d -> Vector59.Vector59 e -> Vector59.Vector59 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector59.Index -> (a -> a) -> Vector59.Vector59 a -> Vector59.Vector59 a"},{"name":"member","comment":" See if a Vector59 a contains a value ","type":"a -> Vector59.Vector59 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector59.Index -> Maybe.Maybe Vector59.Index"},{"name":"pop","comment":" Separate a `Vector59 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector59.Vector59 a -> ( Vector58.Internal.Vector58 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector59.Index -> Maybe.Maybe Vector59.Index"},{"name":"push","comment":" Add an element to the end of a `Vector59 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector59.Vector59 a -> Vector60.Internal.Vector60 a"},{"name":"repeat","comment":" Make a `Vector59 a` filled with just one item repeated over and over again. ","type":"a -> Vector59.Vector59 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector59 a` ","type":"Vector59.Vector59 a -> Vector59.Vector59 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector59 a` ","type":"Vector59.Index -> a -> Vector59.Vector59 a -> Vector59.Vector59 a"},{"name":"toIndexedList","comment":" Turn a `Vector59 a` elm into a list, where each element is paired with its `Index` ","type":"Vector59.Vector59 a -> List.List ( Vector59.Index, a )"},{"name":"toList","comment":" Convert a `Vector59 a` into a `List a` of length 59 ","type":"Vector59.Vector59 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector59 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector59.Vector59 a -> ( a, Vector58.Internal.Vector58 a )"}],"binops":[]},{"name":"Vector6","comment":" A vector of length 6\n\n# Vector6\n\n@docs Vector6\n\n# Creation\n\n@docs fromList, repeat, from6, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector6 a`. There are exactly 6 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]]]}],"aliases":[{"name":"Vector6","comment":" A vector that contains exactly 6 elements ","args":["a"],"type":"Vector6.Internal.Vector6 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector6.Vector6 a -> Vector7.Internal.Vector7 a"},{"name":"foldl","comment":" Reduce a `Vector6 a` from the left. ","type":"(a -> b -> b) -> b -> Vector6.Vector6 a -> b"},{"name":"foldr","comment":" Reduce a `Vector6 a` from the right. ","type":"(a -> b -> b) -> b -> Vector6.Vector6 a -> b"},{"name":"from6","comment":" Make a `Vector6 a` from 6 elements ","type":"a -> a -> a -> a -> a -> a -> Vector6.Vector6 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector6 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector6.Vector6 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector6 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector6.Vector6 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector6 a` ","type":"Vector6.Index -> Vector6.Vector6 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector6 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector6.Vector6 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector6.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector6.Index -> a -> b) -> Vector6.Vector6 a -> Vector6.Vector6 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 5 ","type":"Vector6.Vector6 Vector6.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector6 a` using a function that takes an `Index` ","type":"(Vector6.Index -> a) -> Vector6.Vector6 a"},{"name":"initializeFromInt","comment":" Make a `Vector6 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector6.Vector6 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector6 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector6.Index"},{"name":"length","comment":" The length of this vector type, which is 6 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector6 a`. ","type":"(a -> b) -> Vector6.Vector6 a -> Vector6.Vector6 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector6.Vector6 a -> Vector6.Vector6 b -> Vector6.Vector6 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector6.Vector6 a -> Vector6.Vector6 b -> Vector6.Vector6 c -> Vector6.Vector6 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector6.Vector6 a -> Vector6.Vector6 b -> Vector6.Vector6 c -> Vector6.Vector6 d -> Vector6.Vector6 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector6.Vector6 a -> Vector6.Vector6 b -> Vector6.Vector6 c -> Vector6.Vector6 d -> Vector6.Vector6 e -> Vector6.Vector6 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector6.Index -> (a -> a) -> Vector6.Vector6 a -> Vector6.Vector6 a"},{"name":"member","comment":" See if a Vector6 a contains a value ","type":"a -> Vector6.Vector6 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector6.Index -> Maybe.Maybe Vector6.Index"},{"name":"pop","comment":" Separate a `Vector6 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector6.Vector6 a -> ( Vector5.Internal.Vector5 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector6.Index -> Maybe.Maybe Vector6.Index"},{"name":"push","comment":" Add an element to the end of a `Vector6 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector6.Vector6 a -> Vector7.Internal.Vector7 a"},{"name":"repeat","comment":" Make a `Vector6 a` filled with just one item repeated over and over again. ","type":"a -> Vector6.Vector6 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector6 a` ","type":"Vector6.Vector6 a -> Vector6.Vector6 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector6 a` ","type":"Vector6.Index -> a -> Vector6.Vector6 a -> Vector6.Vector6 a"},{"name":"toIndexedList","comment":" Turn a `Vector6 a` elm into a list, where each element is paired with its `Index` ","type":"Vector6.Vector6 a -> List.List ( Vector6.Index, a )"},{"name":"toList","comment":" Convert a `Vector6 a` into a `List a` of length 6 ","type":"Vector6.Vector6 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector6 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector6.Vector6 a -> ( a, Vector5.Internal.Vector5 a )"}],"binops":[]},{"name":"Vector60","comment":" A vector of length 60\n\n# Vector60\n\n@docs Vector60\n\n# Creation\n\n@docs fromList, repeat, from60, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector60 a`. There are exactly 60 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]],["Index9",[]],["Index10",[]],["Index11",[]],["Index12",[]],["Index13",[]],["Index14",[]],["Index15",[]],["Index16",[]],["Index17",[]],["Index18",[]],["Index19",[]],["Index20",[]],["Index21",[]],["Index22",[]],["Index23",[]],["Index24",[]],["Index25",[]],["Index26",[]],["Index27",[]],["Index28",[]],["Index29",[]],["Index30",[]],["Index31",[]],["Index32",[]],["Index33",[]],["Index34",[]],["Index35",[]],["Index36",[]],["Index37",[]],["Index38",[]],["Index39",[]],["Index40",[]],["Index41",[]],["Index42",[]],["Index43",[]],["Index44",[]],["Index45",[]],["Index46",[]],["Index47",[]],["Index48",[]],["Index49",[]],["Index50",[]],["Index51",[]],["Index52",[]],["Index53",[]],["Index54",[]],["Index55",[]],["Index56",[]],["Index57",[]],["Index58",[]],["Index59",[]]]}],"aliases":[{"name":"Vector60","comment":" A vector that contains exactly 60 elements ","args":["a"],"type":"Vector60.Internal.Vector60 a"}],"values":[{"name":"foldl","comment":" Reduce a `Vector60 a` from the left. ","type":"(a -> b -> b) -> b -> Vector60.Vector60 a -> b"},{"name":"foldr","comment":" Reduce a `Vector60 a` from the right. ","type":"(a -> b -> b) -> b -> Vector60.Vector60 a -> b"},{"name":"from60","comment":" Make a `Vector60 a` from 60 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector60.Vector60 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector60 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector60.Vector60 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector60 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector60.Vector60 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector60 a` ","type":"Vector60.Index -> Vector60.Vector60 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector60 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector60.Vector60 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector60.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector60.Index -> a -> b) -> Vector60.Vector60 a -> Vector60.Vector60 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 59 ","type":"Vector60.Vector60 Vector60.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector60 a` using a function that takes an `Index` ","type":"(Vector60.Index -> a) -> Vector60.Vector60 a"},{"name":"initializeFromInt","comment":" Make a `Vector60 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector60.Vector60 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector60 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector60.Index"},{"name":"length","comment":" The length of this vector type, which is 60 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector60 a`. ","type":"(a -> b) -> Vector60.Vector60 a -> Vector60.Vector60 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector60.Vector60 a -> Vector60.Vector60 b -> Vector60.Vector60 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector60.Vector60 a -> Vector60.Vector60 b -> Vector60.Vector60 c -> Vector60.Vector60 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector60.Vector60 a -> Vector60.Vector60 b -> Vector60.Vector60 c -> Vector60.Vector60 d -> Vector60.Vector60 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector60.Vector60 a -> Vector60.Vector60 b -> Vector60.Vector60 c -> Vector60.Vector60 d -> Vector60.Vector60 e -> Vector60.Vector60 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector60.Index -> (a -> a) -> Vector60.Vector60 a -> Vector60.Vector60 a"},{"name":"member","comment":" See if a Vector60 a contains a value ","type":"a -> Vector60.Vector60 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector60.Index -> Maybe.Maybe Vector60.Index"},{"name":"pop","comment":" Separate a `Vector60 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector60.Vector60 a -> ( Vector59.Internal.Vector59 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector60.Index -> Maybe.Maybe Vector60.Index"},{"name":"repeat","comment":" Make a `Vector60 a` filled with just one item repeated over and over again. ","type":"a -> Vector60.Vector60 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector60 a` ","type":"Vector60.Vector60 a -> Vector60.Vector60 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector60 a` ","type":"Vector60.Index -> a -> Vector60.Vector60 a -> Vector60.Vector60 a"},{"name":"toIndexedList","comment":" Turn a `Vector60 a` elm into a list, where each element is paired with its `Index` ","type":"Vector60.Vector60 a -> List.List ( Vector60.Index, a )"},{"name":"toList","comment":" Convert a `Vector60 a` into a `List a` of length 60 ","type":"Vector60.Vector60 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector60 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector60.Vector60 a -> ( a, Vector59.Internal.Vector59 a )"}],"binops":[]},{"name":"Vector7","comment":" A vector of length 7\n\n# Vector7\n\n@docs Vector7\n\n# Creation\n\n@docs fromList, repeat, from7, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector7 a`. There are exactly 7 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]]]}],"aliases":[{"name":"Vector7","comment":" A vector that contains exactly 7 elements ","args":["a"],"type":"Vector7.Internal.Vector7 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector7.Vector7 a -> Vector8.Internal.Vector8 a"},{"name":"foldl","comment":" Reduce a `Vector7 a` from the left. ","type":"(a -> b -> b) -> b -> Vector7.Vector7 a -> b"},{"name":"foldr","comment":" Reduce a `Vector7 a` from the right. ","type":"(a -> b -> b) -> b -> Vector7.Vector7 a -> b"},{"name":"from7","comment":" Make a `Vector7 a` from 7 elements ","type":"a -> a -> a -> a -> a -> a -> a -> Vector7.Vector7 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector7 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector7.Vector7 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector7 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector7.Vector7 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector7 a` ","type":"Vector7.Index -> Vector7.Vector7 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector7 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector7.Vector7 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector7.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector7.Index -> a -> b) -> Vector7.Vector7 a -> Vector7.Vector7 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 6 ","type":"Vector7.Vector7 Vector7.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector7 a` using a function that takes an `Index` ","type":"(Vector7.Index -> a) -> Vector7.Vector7 a"},{"name":"initializeFromInt","comment":" Make a `Vector7 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector7.Vector7 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector7 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector7.Index"},{"name":"length","comment":" The length of this vector type, which is 7 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector7 a`. ","type":"(a -> b) -> Vector7.Vector7 a -> Vector7.Vector7 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector7.Vector7 a -> Vector7.Vector7 b -> Vector7.Vector7 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector7.Vector7 a -> Vector7.Vector7 b -> Vector7.Vector7 c -> Vector7.Vector7 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector7.Vector7 a -> Vector7.Vector7 b -> Vector7.Vector7 c -> Vector7.Vector7 d -> Vector7.Vector7 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector7.Vector7 a -> Vector7.Vector7 b -> Vector7.Vector7 c -> Vector7.Vector7 d -> Vector7.Vector7 e -> Vector7.Vector7 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector7.Index -> (a -> a) -> Vector7.Vector7 a -> Vector7.Vector7 a"},{"name":"member","comment":" See if a Vector7 a contains a value ","type":"a -> Vector7.Vector7 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector7.Index -> Maybe.Maybe Vector7.Index"},{"name":"pop","comment":" Separate a `Vector7 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector7.Vector7 a -> ( Vector6.Internal.Vector6 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector7.Index -> Maybe.Maybe Vector7.Index"},{"name":"push","comment":" Add an element to the end of a `Vector7 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector7.Vector7 a -> Vector8.Internal.Vector8 a"},{"name":"repeat","comment":" Make a `Vector7 a` filled with just one item repeated over and over again. ","type":"a -> Vector7.Vector7 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector7 a` ","type":"Vector7.Vector7 a -> Vector7.Vector7 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector7 a` ","type":"Vector7.Index -> a -> Vector7.Vector7 a -> Vector7.Vector7 a"},{"name":"toIndexedList","comment":" Turn a `Vector7 a` elm into a list, where each element is paired with its `Index` ","type":"Vector7.Vector7 a -> List.List ( Vector7.Index, a )"},{"name":"toList","comment":" Convert a `Vector7 a` into a `List a` of length 7 ","type":"Vector7.Vector7 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector7 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector7.Vector7 a -> ( a, Vector6.Internal.Vector6 a )"}],"binops":[]},{"name":"Vector8","comment":" A vector of length 8\n\n# Vector8\n\n@docs Vector8\n\n# Creation\n\n@docs fromList, repeat, from8, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector8 a`. There are exactly 8 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]]]}],"aliases":[{"name":"Vector8","comment":" A vector that contains exactly 8 elements ","args":["a"],"type":"Vector8.Internal.Vector8 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector8.Vector8 a -> Vector9.Internal.Vector9 a"},{"name":"foldl","comment":" Reduce a `Vector8 a` from the left. ","type":"(a -> b -> b) -> b -> Vector8.Vector8 a -> b"},{"name":"foldr","comment":" Reduce a `Vector8 a` from the right. ","type":"(a -> b -> b) -> b -> Vector8.Vector8 a -> b"},{"name":"from8","comment":" Make a `Vector8 a` from 8 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> Vector8.Vector8 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector8 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector8.Vector8 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector8 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector8.Vector8 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector8 a` ","type":"Vector8.Index -> Vector8.Vector8 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector8 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector8.Vector8 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector8.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector8.Index -> a -> b) -> Vector8.Vector8 a -> Vector8.Vector8 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 7 ","type":"Vector8.Vector8 Vector8.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector8 a` using a function that takes an `Index` ","type":"(Vector8.Index -> a) -> Vector8.Vector8 a"},{"name":"initializeFromInt","comment":" Make a `Vector8 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector8.Vector8 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector8 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector8.Index"},{"name":"length","comment":" The length of this vector type, which is 8 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector8 a`. ","type":"(a -> b) -> Vector8.Vector8 a -> Vector8.Vector8 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector8.Vector8 a -> Vector8.Vector8 b -> Vector8.Vector8 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector8.Vector8 a -> Vector8.Vector8 b -> Vector8.Vector8 c -> Vector8.Vector8 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector8.Vector8 a -> Vector8.Vector8 b -> Vector8.Vector8 c -> Vector8.Vector8 d -> Vector8.Vector8 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector8.Vector8 a -> Vector8.Vector8 b -> Vector8.Vector8 c -> Vector8.Vector8 d -> Vector8.Vector8 e -> Vector8.Vector8 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector8.Index -> (a -> a) -> Vector8.Vector8 a -> Vector8.Vector8 a"},{"name":"member","comment":" See if a Vector8 a contains a value ","type":"a -> Vector8.Vector8 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector8.Index -> Maybe.Maybe Vector8.Index"},{"name":"pop","comment":" Separate a `Vector8 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector8.Vector8 a -> ( Vector7.Internal.Vector7 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector8.Index -> Maybe.Maybe Vector8.Index"},{"name":"push","comment":" Add an element to the end of a `Vector8 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector8.Vector8 a -> Vector9.Internal.Vector9 a"},{"name":"repeat","comment":" Make a `Vector8 a` filled with just one item repeated over and over again. ","type":"a -> Vector8.Vector8 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector8 a` ","type":"Vector8.Vector8 a -> Vector8.Vector8 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector8 a` ","type":"Vector8.Index -> a -> Vector8.Vector8 a -> Vector8.Vector8 a"},{"name":"toIndexedList","comment":" Turn a `Vector8 a` elm into a list, where each element is paired with its `Index` ","type":"Vector8.Vector8 a -> List.List ( Vector8.Index, a )"},{"name":"toList","comment":" Convert a `Vector8 a` into a `List a` of length 8 ","type":"Vector8.Vector8 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector8 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector8.Vector8 a -> ( a, Vector7.Internal.Vector7 a )"}],"binops":[]},{"name":"Vector9","comment":" A vector of length 9\n\n# Vector9\n\n@docs Vector9\n\n# Creation\n\n@docs fromList, repeat, from9, fromListWithDefault, initializeFromInt, initializeFromIndex\n\n# Index\n\n@docs Index, get, set, indices, indexToInt, intToIndex, nextIndex, previousIndex\n\n# Transform\n\n@docs map, mapItem, indexedMap, foldr, foldl, map2, map3, map4, map5\n\n# Lists\n\n@docs toList, toIndexedList\n\n# Methods\n\n@docs pop, uncons,  push, cons\n\n# Util\n\n@docs length, reverse, member, group\n\n","unions":[{"name":"Index","comment":" All the indices to a `Vector9 a`. There are exactly 9 of them. Its kind of like an `Int` except there is a finite amount of them. ","args":[],"cases":[["Index0",[]],["Index1",[]],["Index2",[]],["Index3",[]],["Index4",[]],["Index5",[]],["Index6",[]],["Index7",[]],["Index8",[]]]}],"aliases":[{"name":"Vector9","comment":" A vector that contains exactly 9 elements ","args":["a"],"type":"Vector9.Internal.Vector9 a"}],"values":[{"name":"cons","comment":" Add an element to the front of a vector, incrementing the vector size by 1\n\n    Vector4.cons -1 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 -1 0 1 2 3 ","type":"a -> Vector9.Vector9 a -> Vector10.Internal.Vector10 a"},{"name":"foldl","comment":" Reduce a `Vector9 a` from the left. ","type":"(a -> b -> b) -> b -> Vector9.Vector9 a -> b"},{"name":"foldr","comment":" Reduce a `Vector9 a` from the right. ","type":"(a -> b -> b) -> b -> Vector9.Vector9 a -> b"},{"name":"from9","comment":" Make a `Vector9 a` from 9 elements ","type":"a -> a -> a -> a -> a -> a -> a -> a -> a -> Vector9.Vector9 a"},{"name":"fromList","comment":" Turn a `List a` into a `Vector9 a`. If there are not enough items in the `List a`, then this function returns `Nothing`. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromList []\n    --> Nothing\n\n    Vector3.fromList [ 1 ]\n    --> Nothing\n\n    Vector3.fromList [ 5, 6, 7, 8 ]\n    --> Just ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"List.List a -> Maybe.Maybe ( List.List a, Vector9.Vector9 a )"},{"name":"fromListWithDefault","comment":" Turn a `List a` into a `Vector9 a`. If there are not enough items in the `List a`, then fill in the remaining spots with a default value. The extra items in the input list, if there are any, is returned as the first element in the output tuple.\n\n    Vector3.fromListWithDefault 1 []\n    --> ([] ,Vector3.from3 1 1 1)\n\n    Vector3.fromListWithDefault 2 [ 1 ]\n    --> ([], Vector3.from3 1 2 2)\n\n    Vector3.fromListWithDefault 2 [ 5, 6, 7, 8 ]\n    --> ([ 8 ], Vector3.from3 5 6 7)\n\n ","type":"a -> List.List a -> ( List.List a, Vector9.Vector9 a )"},{"name":"get","comment":" Get the item at that `Index` in a `Vector9 a` ","type":"Vector9.Index -> Vector9.Vector9 a -> a"},{"name":"group","comment":" Break a `List a` down into groups of `Vector9 a`. The output is a tuple, where the left side is a list of the remainder.\n\n    Vector3.group [ 1, 2, 3 ]\n    --> ([] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4 ]\n    --> ([ 4 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5 ]\n    --> ([ 4, 5 ] , [ Vector3.from3 1 2 3 ])\n\n    Vector3.group [ 1, 2, 3, 4, 5, 6 ]\n    --> ([] , [ Vector3.from3 1 2 3, Vector3.from3 4 5 6 ])\n ","type":"List.List a -> ( List.List a, List.List (Vector9.Vector9 a) )"},{"name":"indexToInt","comment":" Turn the `Index` into an `Int` ","type":"Vector9.Index -> Basics.Int"},{"name":"indexedMap","comment":" Apply a function on every element with its index as first argument ","type":"(Vector9.Index -> a -> b) -> Vector9.Vector9 a -> Vector9.Vector9 b"},{"name":"indices","comment":" A list of all the indices, from 0 to 8 ","type":"Vector9.Vector9 Vector9.Index"},{"name":"initializeFromIndex","comment":" Make a `Vector9 a` using a function that takes an `Index` ","type":"(Vector9.Index -> a) -> Vector9.Vector9 a"},{"name":"initializeFromInt","comment":" Make a `Vector9 a` using a function that takes an `Int`, representing the index ","type":"(Basics.Int -> a) -> Vector9.Vector9 a"},{"name":"intToIndex","comment":" Try and turn an `Int` into an `Index`, returning `Nothing` if the `Int` is above the maximum index, or below the zero index, of this `Vector9 a`\n\n        Vector5.intToIndex 4\n        --> Just Vector5.Index4\n\n        Vector3.intToIndex 4\n        --> Nothing ","type":"Basics.Int -> Maybe.Maybe Vector9.Index"},{"name":"length","comment":" The length of this vector type, which is 9 ","type":"Basics.Int"},{"name":"map","comment":" Apply a function to every element in a `Vector9 a`. ","type":"(a -> b) -> Vector9.Vector9 a -> Vector9.Vector9 b"},{"name":"map2","comment":"  ","type":"(a -> b -> c) -> Vector9.Vector9 a -> Vector9.Vector9 b -> Vector9.Vector9 c"},{"name":"map3","comment":"  ","type":"(a -> b -> c -> d) -> Vector9.Vector9 a -> Vector9.Vector9 b -> Vector9.Vector9 c -> Vector9.Vector9 d"},{"name":"map4","comment":"  ","type":"(a -> b -> c -> d -> e) -> Vector9.Vector9 a -> Vector9.Vector9 b -> Vector9.Vector9 c -> Vector9.Vector9 d -> Vector9.Vector9 e"},{"name":"map5","comment":"  ","type":"(a -> b -> c -> d -> e -> f) -> Vector9.Vector9 a -> Vector9.Vector9 b -> Vector9.Vector9 c -> Vector9.Vector9 d -> Vector9.Vector9 e -> Vector9.Vector9 f"},{"name":"mapItem","comment":" Transform just one particular item at a particular `Index` ","type":"Vector9.Index -> (a -> a) -> Vector9.Vector9 a -> Vector9.Vector9 a"},{"name":"member","comment":" See if a Vector9 a contains a value ","type":"a -> Vector9.Vector9 a -> Basics.Bool"},{"name":"nextIndex","comment":" Given an index, get the next one. Unless its the last index in which case there is no next index (`Nothing`) ","type":"Vector9.Index -> Maybe.Maybe Vector9.Index"},{"name":"pop","comment":" Separate a `Vector9 a` into its last element and everything else.\n\n    Vector4.pop (Vector4.from4 0 1 2 3)\n    --> (Vector3.from3 0 1 2, 3) ","type":"Vector9.Vector9 a -> ( Vector8.Internal.Vector8 a, a )"},{"name":"previousIndex","comment":" Given an index, get the previous one. Unless its the `0` index in which case there is no previous index (`Nothing`) ","type":"Vector9.Index -> Maybe.Maybe Vector9.Index"},{"name":"push","comment":" Add an element to the end of a `Vector9 a`, incrementing its size by 1\n\n    Vector4.push 4 (Vector4.from4 0 1 2 3)\n    --> Vector5.from5 0 1 2 3 4 ","type":"a -> Vector9.Vector9 a -> Vector10.Internal.Vector10 a"},{"name":"repeat","comment":" Make a `Vector9 a` filled with just one item repeated over and over again. ","type":"a -> Vector9.Vector9 a"},{"name":"reverse","comment":" Reverse the order of the items in a `Vector9 a` ","type":"Vector9.Vector9 a -> Vector9.Vector9 a"},{"name":"set","comment":" Set the item at a specific index in a `Vector9 a` ","type":"Vector9.Index -> a -> Vector9.Vector9 a -> Vector9.Vector9 a"},{"name":"toIndexedList","comment":" Turn a `Vector9 a` elm into a list, where each element is paired with its `Index` ","type":"Vector9.Vector9 a -> List.List ( Vector9.Index, a )"},{"name":"toList","comment":" Convert a `Vector9 a` into a `List a` of length 9 ","type":"Vector9.Vector9 a -> List.List a"},{"name":"uncons","comment":" Split a `Vector9 a` into its first element and the rest\n\n    Vector4.uncons (Vector4.from4 0 1 2 3)\n    --> (0, Vector3.from3 1 2 3) ","type":"Vector9.Vector9 a -> ( a, Vector8.Internal.Vector8 a )"}],"binops":[]}]